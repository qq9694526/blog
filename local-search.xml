<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Web前端性能优化自查清单</title>
    <link href="/2022/03/09/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%87%AA%E6%9F%A5%E6%B8%85%E5%8D%95/"/>
    <url>/2022/03/09/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%87%AA%E6%9F%A5%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一份简洁、纯粹的Web前端性能优化清单。每个优化点都包含有概念、实操和参考资料。面试、实战两相宜。</p><p>这是一个大工程。在正式开始之前，先统一下语言，澄清每一部分的目的和要求，防止跑偏。</p><ul><li><p>概念：把官话翻译成能看懂、能记住的人话，原则上易读性 &gt; 专业性</p></li><li><p>实操：自己操作一遍，不做云玩家；记录核心实现，方便CV</p></li><li><p>参考资料：信息来源选用一手资料，以便保证信息的完整性、准确性和时效性。除非看一手的理解不了…… </p></li></ul><h3 id="一、网络层面"><a href="#一、网络层面" class="headerlink" title="一、网络层面"></a>一、网络层面</h3><h4 id="1-DNS预解析"><a href="#1-DNS预解析" class="headerlink" title="1. DNS预解析"></a>1. DNS预解析</h4><p><strong>概念</strong></p><p><code>DNS-prefetch</code> 是一种 DNS 预解析技术。它会在请求跨域资源之前，预先解析并进行DNS缓存，以减少真正请求时DNS解析导致的请求延迟。对于打开包含有许多第三方连接的网站，效果明显。</p><p><strong>实操</strong></p><p>添加ref属性为“dns-prefetch”的link标签。一般放在在html的head中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;dns-prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//xxx.download.com&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>href</code>的值就是要预解析的域名，对应后面要加载的资源或用户有可能打开链接的域名。</p><p><strong>备注</strong></p><p>同理，也有“ TCP/IP预连接”，叫preconnect。参考资料中有完整的描述。</p><p><strong>参考资料</strong></p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/dns-prefetch">MDN Web Docs</a></li></ul><h4 id="2-应用浏览器缓存"><a href="#2-应用浏览器缓存" class="headerlink" title="2. 应用浏览器缓存"></a>2. 应用浏览器缓存</h4><p><strong>概念</strong></p><p>浏览器缓存是浏览器存放在本地磁盘或者内存中的请求结果的备份。当有相同请求进来时，直接响应本地备份，而无需每次都从原始服务器获取。这样不仅提升了客户端的响应效率，同时还能缓解服务器的访问压力。</p><p>其间，约定何时、如何使用缓存的规则，被称为缓存策略。分为强缓存和协商缓存。</p><p>整个缓存执行的过程大致如下：</p><p>①. 请求发起，浏览器判断本地缓存，如果有且未到期，则命中<strong>强缓存</strong>。浏览器响应本地备份，状态码为200。控制台Network中size那一项显示disk cache;</p><p>②. 如果没有缓存或者缓存已过期，则请求原始服务器询问文件是否有变化。服务器根据请求头中的相关字段，判断目标文件新鲜度；</p><p>③. 如果目标文件没变更，则命中<strong>协商缓存</strong>，服务器设置新的过期时间，浏览器响应本地备份，状态码为304；</p><p>④. 如果目标文件有变化，则服务器响应新文件，状态码为200。浏览器更新本地备份。</p><p>上述过程有几个关键点</p><ul><li><p>如何判断缓存是否过期？</p><p>浏览器读取缓存的请求结果中响应头的Expires 和Cache-Control，与当前时间进行比较。</p><p>其中，<code>Expires</code>是HTTP 1.0的字段，值是一个是绝对时间。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">Expires: Tue, 18 Jan 2022 09:53:23 GMT<br></code></pre></td></tr></table></figure><p>比较绝对时间，有一个弊端，它依赖计算机时钟被正确设置。</p><p>为了解决这个问题，HTTP1.1 新增了<code>Cache-Control</code>字段，它的值是一个是相对时间。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">Cache-Control: max-age=60  //单位是秒<br></code></pre></td></tr></table></figure></li><li><p>如何判断文件是否变化？</p><p>首先可以通过比较 最后修改时间。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 缓存结果的 响应头<br>Last-Modified: Mon, 10 Jan 2022 09:06:14 GMT<br>// 新请求的 请求头<br>If-Modified-Since: Mon, 10 Jan 2022 09:06:14 GMT<br></code></pre></td></tr></table></figure><p>浏览器取出缓存结果中<code>Last-Modified</code>的值，通过<code>If-Modified-Since</code>上送到服务端。与服务器中目标文件的最后修改时间做比较。</p><p>再者可以通过比较 Etag。</p><blockquote><p>Etag实体标签是附加到文档上的任意标签(引用字符串)。它们可能包含了文档的序列号或版本名，或者是文档内容的校验和及其他指纹信息。当发布者对文档进行修改时，会修改文档的实体标签来说明这是个新的版本。</p></blockquote><p>从响应头的<code>ETag</code>取值，通过请求头的<code>If-None-Match</code>上送，与服务器目标文件的Etag标签比对。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 缓存的 响应头<br>ETag: &quot;61dbf706-142&quot;<br>// 上送的 请求头<br>If-None-Match: &quot;61dbf706-142&quot;<br></code></pre></td></tr></table></figure><p>和上面一样，新增的字段也是为了解决前一种方案的某些缺陷：</p><blockquote><ul><li>有些文档可能会被周期性地重写(比如，从一个后台进程中写入)，但实际包含的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。</li><li>有些文档可能被修改了，但所做修改并不重要，不需要让世界范围内的缓存都重装数据(比如对拼写或注释的修改)。</li><li>有些服务器无法准确地判定其页面的最后修改日期。</li><li>有些服务器提供的文档会在亚秒间隙发生变化(比如，实时监视器)，对这些服务器来说，以一秒为粒度的修改日期可能就不够用了。</li></ul></blockquote></li><li><p>如果两个版本的字段同时存在，怎么办？</p><p>出于浏览器兼容方面的考虑 ，一般两组字段会被同时使用。他们没有优先级一说，取并集。</p><p>同时出现时，只有当两个条件都满足，才会命中相应缓存。</p></li></ul><p><strong>实操</strong></p><p>缓存是web服务器和浏览器的核心能力，主流的web服务框架 nginx、koa-static等都内置有上述缓存策略的实现。开箱即用，无需额外编程或配置。</p><p>以Nginx举例。强缓存的配置字段是<code>expires</code>，它接受一个数字，单位是秒。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br><span class="hljs-attribute">listen</span>       <span class="hljs-number">8080</span>;<br><span class="hljs-attribute">location</span> / &#123;<br><span class="hljs-attribute">root</span>   /Users/zhp/demo/cache-koa/static;<br><span class="hljs-attribute">index</span> index.html;<br>    <span class="hljs-comment"># 注意try_files会导致缓存配置不生效</span><br><span class="hljs-comment"># try_files $uri $uri/ /index.html;</span><br><span class="hljs-attribute">expires</span>     <span class="hljs-number">60</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际工作中确实配置一下就好了，但这体现不出什么知识点。为了加深印象，我这用koa简陋的模拟了一下，算是对上面那些知识点的验证。</p><p>下面是一个极简的静态资源服务，不带缓存的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">app.use(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  <span class="hljs-comment">// 1.根据访问路径读取指定文件</span><br>  <span class="hljs-keyword">const</span> content = fs.readFileSync(<span class="hljs-string">`./static<span class="hljs-subst">$&#123;ctx.path&#125;</span>`</span>, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>  <span class="hljs-comment">// 2.设置响应</span><br>ctx.body = content;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这种情况，无论访问多少次都是不进缓存的。</p><p>现在，在响应头加上强缓存所需的<code>Exprise</code>和<code>Cache-Control</code>字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">app.use(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  <span class="hljs-comment">// 1.根据访问路径读取指定文件</span><br>  <span class="hljs-keyword">const</span> content = fs.readFileSync(<span class="hljs-string">`./static<span class="hljs-subst">$&#123;ctx.path&#125;</span>`</span>, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>  <span class="hljs-comment">// 2.设置缓存</span><br>  ctx.response.set(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;max-age=60&quot;</span>);<br>  ctx.response.set(<span class="hljs-string">&#x27;Exprise&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()+<span class="hljs-number">60</span>*<span class="hljs-number">1000</span>));<br><span class="hljs-comment">// 3.设置响应</span><br>ctx.body = content;<br>&#125;);<br></code></pre></td></tr></table></figure><p>查看Network，响应头会多出下面两个字段，且间隔60秒内的请求会走缓存，符合预期。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">Expires: Tue, 18 Jan 2022 10:05:09 GMT<br>Cache-Control: max-age=60<br></code></pre></td></tr></table></figure><p><strong>备注</strong></p><p>抱着引用一手权威资料的想法，扒了《HTTP权威指南》，但读感着实差强人意。新手建议《图解HTTP》起手，要友好很多。</p><p><strong>参考资料</strong></p><ul><li><a href="">《HTTP权威指南》</a></li><li><a href="https://zhuanlan.zhihu.com/p/58685072">HTTP 缓存机制</a></li><li><a href="https://www.nginx.cn/doc/standard/httpheaders.html">Nginx中文文档</a></li></ul><h4 id="3-静态资源CDN"><a href="#3-静态资源CDN" class="headerlink" title="3. 静态资源CDN"></a>3. 静态资源CDN</h4><p><strong>概念</strong></p><blockquote><p>CDN的全称是Content Delivery Network，即<a href="https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/4034265">内容分发网络</a>。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p></blockquote><p>核心功效总结起来就两点：</p><p>①. 通过负载均衡技术 ，为用户的请求选择最佳的服务节点；</p><p>②. 通过内容缓存服务，提高用户访问响应速度。</p><p><strong>实操</strong></p><p>普通玩家：选择一个CDN服务商，看它提供的使用文档。通过配置域名和源站，代理到自己的静态资源服务器。</p><p>高级玩家：自建CDN服务器，balabal……</p><p><strong>参考资料</strong></p><ul><li><a href="https://help.aliyun.com/document_detail/27111.html">阿里云CDN快速入门</a></li></ul><h4 id="4-开启Gzip"><a href="#4-开启Gzip" class="headerlink" title="4. 开启Gzip"></a>4. 开启Gzip</h4><p><strong>概念</strong></p><blockquote><p>gzip是GNUzip的缩写，最早用于UNIX系统的文件压缩。HTTP协议上的gzip编码是一种用来改进web应用程序性能的技术，web服务器和客户端（浏览器）必须共同支持gzip。gzip压缩比率在3到10倍左右，可以大大节省服务器的网络带宽。</p></blockquote><p><strong>实操</strong></p><p>实际操作过程中分为动态压缩和静态压缩。</p><ul><li><p>动态压缩。指当收到请求后，服务器实时压缩然后输出数据流。服务器存放的是css/js文件。<br>Nginx的<a href="https://www.nginx.cn/doc/standard/httpgzip.html">httpGzip</a>模块，支持该功能。主要配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 开启或者关闭gzip模块</span><br><span class="hljs-attribute">gzip</span>             <span class="hljs-literal">on</span>; <br><span class="hljs-comment"># 设置允许压缩的页面最小字节数。建议设置成大于1k的字节数，小于1k可能会越压越大。</span><br><span class="hljs-attribute">gzip_min_length</span>  <span class="hljs-number">1024</span>;<br><span class="hljs-comment"># 匹配MIME类型进行压缩，（无论是否指定）&quot;text/html&quot;类型总是会被压缩的。</span><br><span class="hljs-attribute">gzip_types</span>       text/plain application/x-javascript text/css text/html application/xml;<br></code></pre></td></tr></table></figure></li><li><p>静态压缩。服务器一开始存放的就是已经压缩好的文件，当接受请求后直接响应压缩资源，而不是收到请求后才压缩。</p><p>使用Webpack + Nginx的实现：</p><p>①. 安装并应用compression-webpack-plugin压缩插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ## 安装 ##</span><br><span class="hljs-comment">// 注意高版本会报错 Cannot read property &#x27;tapPromise&#x27; of undefined</span><br>npm i --save-dev compression-webpack-plugin@<span class="hljs-number">5.0</span><span class="hljs-number">.1</span><br><br><span class="hljs-comment">// ## webpack配置 ##</span><br><span class="hljs-comment">// vue.config.js</span><br><span class="hljs-keyword">const</span> CompressionPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;compression-webpack-plugin&quot;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  configureWebpack:&#123;<br>    plugins: [<br>      <span class="hljs-keyword">new</span> CompressionPlugin()<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>②. 执行构建<code>npm run build</code></p><p>打包完成后，在dist目录下会多出.gz结尾的压缩文件</p><p>③. Nginx配置开启<a href="https://www.nginx.cn/doc/optional/gzipstatic.html">gzip_static</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nginx">http&#123;<br>    <span class="hljs-attribute">gzip_static</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">8082</span>;<br>        <span class="hljs-attribute">location</span> / &#123;<br>            <span class="hljs-attribute">root</span>   /Users/zhp/demo/demo-externals/dist;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>结果验证</p><p>在Response Header中看到有<code>Content-Encoding: gzip</code>，说明服务器配置生效；</p><p>在Network的Size列看数据比服务器上源文件要小，说明浏览器支持，Gzip生效。</p></li></ul><p><strong>备注</strong></p><p>gzip_static的优先级高于gzip。当gzip和gzip_static都开启时，nginx会优先匹配.gz文件，然后才走动态压缩。</p><p><strong>参考资料：</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/24764131">你真的了解 gzip 吗？</a></li><li><a href="https://www.npmjs.com/package/compression-webpack-plugin">https://www.npmjs.com/package/compression-webpack-plugin</a></li></ul><h4 id="5-使用高版本的HTTP协议"><a href="#5-使用高版本的HTTP协议" class="headerlink" title="5. 使用高版本的HTTP协议"></a>5. 使用高版本的HTTP协议</h4><p><strong>概念</strong></p><p>从1.0到1.1再到如今的2.0，HTTP协议在持续迭代中，变的更快更强。</p><p>其间的变更内容多且硬核，这里出于解释高版本优势的目的，简单的列举一二，HTTP/1.1的持久连接和管道化技术、2.0的多路复用和首部压缩。</p><ul><li><p>持久连接</p><blockquote><p>HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP连接。为了减少了TCP 连接的重复建立和断开所造成的额外开销。 HTTP/1.1 和一部分的 HTTP/1.0 想出了 持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或HTTP connection reuse）的方法。持久连接的特点是，只要任意一端 没有明确提出断开连接，则保持 TCP 连接状态。</p></blockquote></li><li><p>管道化</p><blockquote><p>从前，发送请求后需等待并收到响应，才能发送下一个请求。管道化技术允许客户端同时并行发送多个请求，而不需要一个接一个地等待响应。</p></blockquote><p><img src="http://7niu.zhaohaipeng.com/image-20220207195536838.png" alt="image-20220207195536838"> </p></li><li><p>多路复用</p><blockquote><p>HTTP/1.1，即便是通过管道同时发送了多个请求，服务端也是按请求的顺序依次给出响应的。客户端在未收到之前所发出所有请求的响应之前，将会阻塞后面的请求(排队等待)，这称为”队头堵塞”（Head-of-line blocking）。</p><p>HTTP/2引入二进制数据帧的概念，对数据进行顺序标识，浏览器收到数据之后，可以按照序列对数据进行合并，使得服务端可以并行的传输数据。</p><p>解决了顺序问题，我们在一个TCP连接上，就可以向对方不断发送一个个的消息，这里每一个消息看成是一帧，而每一帧有个stream identifier的字段标明这一帧属于哪个“流”，然后在对方接收时，根据stream identifier拼接每个“流”的所有帧组成一整块数据。</p><p>我们把HTTP/1.x每个请求都当作一个“流”，那么请求化成多个流，请求响应数据切成多个帧，不同流中的帧交错地发送给对方，这就是HTTP/2中的多路复用。</p></blockquote><p>最终达成的效果就是，同一域名不管访问多少文件多少请求，也只需<strong>建立一路连接</strong>。</p></li><li><p>首部压缩</p><blockquote><p>在HTTP/1.x中首部是没有压缩的，gzip只会压缩body，HTTP/2提供了首部压缩方案。一般轮询请求首部，特别是cookie占用很多大部份空间，首部压缩使得整个HTTP数据包小了很多，传输也就会更快。</p></blockquote></li></ul><p><strong>实操</strong></p><p>主流Web服务器 Nginx、Tomcat等都有对HTTP/2的支持，具体配置自行参考官方文档（笔者驾驭不住😂）。 </p><p><strong>备注</strong></p><p>mark一下如何查看协议版本信息。在Network中对着表头右键，弹窗中勾选Protocol这一项。</p><p><img src="http://7niu.zhaohaipeng.com/WX20220112-200043@2x.png" alt="WX20220112-200043@2x"></p><p><strong>参考资料</strong></p><ul><li><a href="">《HTTP权威指南》</a></li><li><a href="https://www.kancloud.cn/digest/web-performance-http2/74825">Web性能优化与HTTP/2</a></li><li><a href="https://segmentfault.com/a/1190000011172823">浅析HTTP/2的多路复用</a></li></ul><h3 id="二、代码层面"><a href="#二、代码层面" class="headerlink" title="二、代码层面"></a>二、代码层面</h3><h4 id="1-优化DOM操作"><a href="#1-优化DOM操作" class="headerlink" title="1. 优化DOM操作"></a>1. 优化DOM操作</h4><p><strong>概念</strong></p><p>众所周知，浏览器的渲染成本是极其昂贵的。通过合并DOM操作，可以避免频繁的触发重排重绘，以提升渲染效率。</p><p>优化DOM操作的最佳实践，莫过于大名鼎鼎的虚拟DOM。</p><blockquote><p>virtual DOM <em>虚拟DOM</em>，用普通JS对象来描述DOM结构，因为不是真实DOM,所以称之为<em>虚拟DOM</em></p></blockquote><p>它的价值在于：</p><p>①. 查找 JS 对象的属性要比查询 DOM 树的开销要小；</p><p>②. 当数据驱动频繁触发DOM操作的时候，所有变化先反映在这个 JS 对象上。最终在一个宏任务（EventLoop机制）中统一执行所有变更，达成合并DOM操作的效果；</p><p>③. 可以方便的通过比较新旧两个虚拟DOM（Diff算法），最大程度的缩小DOM变更范围。</p><p><strong>实操</strong></p><p>Vue和React都引入有虚拟DOM的概念，加上数据驱动，使得我们在使用框架后，已经不需要再关注具体的DOM操作了。</p><p><strong>备注</strong></p><p>这一节本应是一堆原生DOM操作的例子，但在Vue、React一统天下的当下讲太多这些，着实会显得有些过时。</p><p><strong>参考资料</strong></p><ul><li><a href="https://v3.cn.vuejs.org/guide/optimizations.html#%E8%99%9A%E6%8B%9F-dom">https://v3.cn.vuejs.org/guide/optimizations.html#%E8%99%9A%E6%8B%9F-dom</a></li></ul><h4 id="2-事件委托"><a href="#2-事件委托" class="headerlink" title="2. 事件委托"></a>2. 事件委托</h4><p><strong>概念</strong></p><p>简单来讲，就是当我们绑定事件时，不直接绑到目标元素，而是绑到其父/祖先元素上的绑事件策略。</p><p>这样做有两个好处：①. 页面监听的事件少；②. 当新增子节点时，不需要再绑定事件。</p><p><strong>实操</strong></p><p>以”鼠标放到li上对应的li背景变灰“这个需求场景举例</p><ul><li>正常绑事件：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item6<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">$(<span class="hljs-string">&quot;li&quot;</span>).on(<span class="hljs-string">&quot;mouseover&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    $(<span class="hljs-built_in">this</span>)</span><br><span class="javascript">      .css(<span class="hljs-string">&quot;background-color&quot;</span>, <span class="hljs-string">&quot;#ddd&quot;</span>)</span><br>      .siblings()<br><span class="javascript">      .css(<span class="hljs-string">&quot;background-color&quot;</span>, <span class="hljs-string">&quot;white&quot;</span>);</span><br>  &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <br></code></pre></td></tr></table></figure><ul><li>利用事件委托：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;ul&quot;</span>).on(<span class="hljs-string">&quot;mouseover&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  $(e.target)<br>    .css(<span class="hljs-string">&quot;background-color&quot;</span>, <span class="hljs-string">&quot;#ddd&quot;</span>)<br>    .siblings()<br>    .css(<span class="hljs-string">&quot;background-color&quot;</span>, <span class="hljs-string">&quot;white&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="3-防抖与节流"><a href="#3-防抖与节流" class="headerlink" title="3. 防抖与节流"></a>3. 防抖与节流</h4><p><strong>概念</strong></p><p>防抖与节流都是为了优化单位时间内大量事件触发，存在的性能问题。它们只是效果不同，适用场景不同。</p><ul><li><p>防抖。单位时间多次连续触发，最终只执行最后的那一次。核心原理是延迟执行，期间但凡有新的触发就重置定时器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-comment">// 1、创建一个标记用来存放定时器的返回值</span><br>  <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 2、每次当用户点击/输入的时候，把前一个定时器清除</span><br>    <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    <span class="hljs-comment">// 3、然后创建一个新的 setTimeout，</span><br>    <span class="hljs-comment">// 这样就能保证点击按钮后的 interval 间隔内,如果用户还点击了的话，就不会执行 fn 函数</span><br>    timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.call(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>经典应用场景：搜索框中的实时搜索，等待用户不再输入内容后再做接口查询。</p></li><li><p>节流。单位时间内事件仅触发一次。核心原理是加锁，只有满足一定间隔时间才执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>     <span class="hljs-comment">// 1、通过闭包保存一个标记</span><br>     <span class="hljs-keyword">let</span> canRun = <span class="hljs-literal">true</span>;<br>     <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>       <span class="hljs-comment">// 2、在函数开头判断标志是否为 true，不为 true 则中断函数</span><br>       <span class="hljs-keyword">if</span>(!canRun) &#123;<br>         <span class="hljs-keyword">return</span>;<br>       &#125;<br>       <span class="hljs-comment">// 3、将 canRun 设置为 false，防止执行之前再被执行</span><br>       canRun = <span class="hljs-literal">false</span>;<br>       <span class="hljs-comment">// 4、定时器</span><br>       <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">() =&gt;</span> &#123;<br>         fn.call(<span class="hljs-built_in">this</span>, args); <span class="hljs-comment">//如果需要立即执行，把改行移到定时器外层</span><br>         <span class="hljs-comment">// 5、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true</span><br>         canRun = <span class="hljs-literal">true</span>;<br>       &#125;, <span class="hljs-number">1000</span>);<br>     &#125;;<br>   &#125;<br></code></pre></td></tr></table></figure><p>经典应用场景：滚动事件等高频触发的场景；按钮防重复点击等</p></li></ul><p><strong>实操</strong></p><p>实际应用时，我们可以直接使用上面的函数，也可以引用第三方类库，比如lodash。</p><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i lodash.debounce<br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#x2F;&#x2F; xxx.vue<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;input type&#x3D;&quot;text&quot; @input&#x3D;&quot;onInput&quot;&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;scrit&gt;<br>import debounce from &quot;lodash.debounce&quot;<br>export default&#123;<br>  methods:&#123;<br>    onInput:debounce((event)&#x3D;&gt;&#123;<br>      console.log(event)<br>    &#125;,1000)<br>  &#125;<br>&#125;<br>&lt;&#x2F;script<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-图片懒加载"><a href="#4-图片懒加载" class="headerlink" title="4. 图片懒加载"></a>4. 图片懒加载</h4><p><strong>概念</strong></p><blockquote><p><em>图片懒加载</em>是针对图片加载时机的一种优化,在一些图片量比较大的网站(比如电商网站首页,或者团购网站、小游戏首页等),如果我们尝试在用户打开页面的时候,就把所有的图片资源加载完毕,那么很可能会造成白屏、卡顿等现象。</p><p>懒加载的意思就是让浏览器只加载可视区内的图片，可视区外的大量图片不进行加载，当页面滚动到后面去的时候再进行加载。避免资源浪费的同时，可以使页面加载更流畅。</p></blockquote><p><strong>实操</strong></p><p>原理很简单，就是先将img src置空，等到图片进入视图区域时再设置src，加载相应资源。但我们没必要真的去实现这些，那是重复造轮子。该类成熟的插件/组件有很多，比如<a href="https://vant-contrib.gitee.io/vant/#/zh-CN/lazyload">Vant的懒加载</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; Lazyload &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vant&#x27;</span>;<br>app.use(Lazyload);<br><br><span class="hljs-comment">// xxx.vue</span><br>&lt;img v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;img in imageList&quot;</span> v-lazy=<span class="hljs-string">&quot;img&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p><strong>备注</strong></p><p>图片只是载体，懒加载贯彻的是按需加载的思路。举一反三，分页查询、路由懒加载、模块异步加载，都是该类别的常用优化。</p><p><strong>参考资料</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/337331845">如何实现图片懒加载</a></li></ul><h3 id="三、-构建层面"><a href="#三、-构建层面" class="headerlink" title="三、 构建层面"></a>三、 构建层面</h3><p>构建工具有很多，这里单练Webpack。</p><blockquote><p>弱水三千只取一瓢</p></blockquote><h4 id="1-路由懒加载"><a href="#1-路由懒加载" class="headerlink" title="1. 路由懒加载"></a>1. 路由懒加载</h4><p><strong>概念：</strong></p><blockquote><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。</p></blockquote><p><strong>实操</strong></p><p>下面是VueRouter关于路由懒加载的官方示例</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 将</span><br><span class="hljs-comment">// import UserDetails from &#x27;./views/UserDetails&#x27;</span><br><span class="hljs-comment">// 替换成</span><br><span class="hljs-keyword">const</span> UserDetails = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./views/UserDetails&#x27;</span>)<br><br><span class="hljs-keyword">const</span> router = createRouter(&#123;<br>  <span class="hljs-comment">// ...</span><br>  routes: [&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:id&#x27;</span>, <span class="hljs-attr">component</span>: UserDetails &#125;],<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>核心实现就两点：</p><p>①. 使用了ES6 的动态导入方法import()，异步的加载模块；</p><p>②. 打包工具，在构建时自动识别并打包成单独的代码块。</p><p>我们还可以通过行内注释<code>/* webpackChunkName: &quot;about&quot; */</code>（Webpack语法），指定代码块的名称，和把多个路由源码构建到同一个块中。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> router.js<br>&#123;<br>  path: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>  name: <span class="hljs-string">&#x27;About&#x27;</span>,<br>  <span class="hljs-regexp">//</span> route level code-splitting<br>  <span class="hljs-regexp">//</span> this generates a separate chunk (about.[hash].js) <span class="hljs-keyword">for</span> this route<br>  <span class="hljs-regexp">//</span> which is lazy-loaded when the route is visited.<br>  component: () =&gt; import(<span class="hljs-regexp">/* webpackChunkName: &quot;about&quot; */</span> <span class="hljs-string">&#x27;../views/About.vue&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>参考资料</strong></p><ul><li><a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a></li></ul><h4 id="2-Externals排除依赖"><a href="#2-Externals排除依赖" class="headerlink" title="2. Externals排除依赖"></a>2. Externals排除依赖</h4><p><strong>概念</strong></p><p>Webpack的<code>externals</code>配置项允许我们从输出的 bundle 中排除指定依赖，排除的依赖不参与构建。</p><p>通常用于配合较大体积第三方依赖使用CDN的场景。</p><p><strong>实操</strong></p><p>以在vue-cli项目中 CDN vue举例</p><ol><li><p>首先在public/index.html添加script引用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html">// public/index.html<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    ...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://lib.baomitu.com/vue/2.6.11/vue.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    ...<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>使用webpack配置项externals排除vue的依赖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// vue.config.js</span><br><span class="hljs-keyword">const</span> BundleAnalyzerPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-bundle-analyzer&#x27;</span>).BundleAnalyzerPlugin;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  configureWebpack:&#123;<br>    plugins: [<br>      <span class="hljs-keyword">new</span> BundleAnalyzerPlugin() <span class="hljs-comment">// 用于输出下图中的打包分析报告 npm run build --report </span><br>    ],<br>    externals: &#123;<br>      vue: <span class="hljs-string">&#x27;Vue&#x27;</span>,<br>    &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用BundleAnalyzerPlugin（打包分析插件）验证结果</p><p>下面两张图，就是改动前后，两次执行<code>npm run build --report</code>得到的分析结果。</p><p><img src="http://7niu.zhaohaipeng.com/image-20220125203908595.png" alt="image-20220125203908595"></p><p><img src="http://7niu.zhaohaipeng.com/image-20220125204600775.png" alt="image-20220125204600775"></p><p>通过比较可以看到，包体积整体减少了200多Kb，且chunk-vendors.js中移除了vue相关依赖。符合预期。</p></li></ol><p><strong>参考资料</strong></p><ul><li><a href="https://webpack.docschina.org/configuration/externals/">Webpack中文文档</a></li><li><a href="https://www.npmjs.com/package/webpack-bundle-analyzer">https://www.npmjs.com/package/webpack-bundle-analyzer</a></li></ul><h4 id="3-TreeShaking按需引入"><a href="#3-TreeShaking按需引入" class="headerlink" title="3. TreeShaking按需引入"></a>3. TreeShaking按需引入</h4><p><strong>概念</strong></p><p>TreeShaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。</p><p>概念早就有了，实现的话则是在ES6之后。主要得益于ES6 Module模块的编译时加载，使得静态分析成为可能。</p><p><strong>实操</strong></p><p>Webpack 4 正式版本，扩展了该项能力。在vue-cli创建的项目中我们不需要任何额外配置，就有效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// assets/util</span><br><span class="hljs-keyword">const</span> funcA =<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;this is funcA&quot;</span>)<br>&#125;<br><span class="hljs-keyword">const</span> funcB =<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;this is funcB&quot;</span>)<br>&#125;<br><span class="hljs-keyword">export</span> &#123;<br>  funcA,<br>  funcB<br>&#125;<br><br><span class="hljs-comment">// app.vue</span><br><span class="hljs-keyword">import</span> &#123; funcA &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./assets/util&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;<br>    funcA();<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>执行<code>npm run build</code>，点开dist/app.xxx.js。可以看到只有funcA 没有B 。符合预期。</p><p><img src="http://7niu.zhaohaipeng.com/image-20220226160108636.png"></p><p>但，当improt第三方插件时，实际并没有生效。比如lodash</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> debounce <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash/debounce&#x27;</span>; <span class="hljs-comment">// 3.35kb</span><br><span class="hljs-keyword">import</span> &#123; debounce &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>; <span class="hljs-comment">// 72.48kb</span><br></code></pre></td></tr></table></figure><p>因为，它的生效需要满足一些条件：</p><blockquote><ul><li>使用 ES2015 模块语法（即 <code>import</code> 和 <code>export</code>）。</li><li>确保没有编译器将您的 ES2015 模块语法转换为 CommonJS 的（顺带一提，这是现在常用的 @babel/preset-env 的默认行为，详细信息请参阅<a href="https://babeljs.io/docs/en/babel-preset-env#modules">文档</a>）。</li><li>在项目的 <code>package.json</code> 文件中，添加 <code>&quot;sideEffects&quot;</code> 属性。</li><li>使用 <code>mode</code> 为 <code>&quot;production&quot;</code> 的配置项以启用<a href="https://webpack.docschina.org/concepts/mode/#usage">更多优化项</a>，包括压缩代码与 tree shaking。</li></ul></blockquote><p>需要注意的是，不是说不支持TreeShaking，就不能按需引入了。在TreeShaking之前，实现该类效果的插件比比皆是，比如babel-plugin-import。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; Button &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span>xxxx<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span></span>);<br><br>      ↓ ↓ ↓ ↓ ↓ ↓<br><br><span class="hljs-keyword">var</span> _button = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;antd/lib/button&#x27;</span>);<br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">_button</span>&gt;</span>xxxx<span class="hljs-tag">&lt;/<span class="hljs-name">_button</span>&gt;</span></span>);<br></code></pre></td></tr></table></figure><p><strong>参考资料</strong></p><ul><li><a href="https://webpack.docschina.org/guides/tree-shaking/">https://webpack.docschina.org/guides/tree-shaking/</a></li><li><a href="https://github.com/umijs/babel-plugin-import">https://github.com/umijs/babel-plugin-import</a></li></ul><h3 id="四、高手进阶"><a href="#四、高手进阶" class="headerlink" title="四、高手进阶"></a>四、高手进阶</h3><p>此处列举一些小众偏门、门槛高、格局大的优化手段。</p><h4 id="1-SSR"><a href="#1-SSR" class="headerlink" title="1. SSR"></a>1. SSR</h4><p><strong>概念</strong></p><p>SSR是Server Side Render（服务端渲染）的简称，与之相对应的是Client Side Render（客户端渲染）。</p><ul><li>服务端渲染：在服务端完成页面插值/数据组装，直接返回包含有数据的页面。</li><li>客户端渲染：客户端分别请求页面静态资源和接口数据，然后操作DOM赋值到页面。</li></ul><p>其实，Web世界诞生的初始，只有服务端渲染这一种方式。 那时.net、jsp如日中天，那时还只有一种程序员，不分前后端。直到Ajax技术的出现，允许人们不刷新页面的获取数据，客户端渲染的大门就此打开，一发而不可收拾。前后端分离、单页应用的流行，更是一步步的把客户端渲染的疆域推向极致。 </p><p>现如今，SSR一般只存在于对首屏时间有苛刻要求、以静态内容为主和需要SEO的场景。 </p><p><strong>实操</strong></p><p>传统的服务端渲染使用后端模板系统或字符串模板引擎就能完成，这里选用复杂度和难度更高的SPA SSR举例。</p><p>下面是Vue SSR官方示例，只是把express换成了我更熟悉的koa。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ssr.js</span><br><span class="hljs-keyword">import</span> Koa <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;koa&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; createSSRApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; renderToString &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue/server-renderer&quot;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();<br><br>app.use(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> vueApp = createSSRApp(&#123;<br>    data: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> &#125;),<br>    template: <span class="hljs-string">`&lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;`</span>,<br>  &#125;);<br>  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> renderToString(vueApp);<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-string">`</span><br><span class="hljs-string">  &lt;!DOCTYPE html&gt;</span><br><span class="hljs-string">  &lt;html&gt;</span><br><span class="hljs-string">    &lt;head&gt;</span><br><span class="hljs-string">      &lt;title&gt;Vue SSR Example&lt;/title&gt;</span><br><span class="hljs-string">    &lt;/head&gt;</span><br><span class="hljs-string">    &lt;body&gt;</span><br><span class="hljs-string">      &lt;div id=&quot;app&quot;&gt;<span class="hljs-subst">$&#123;html&#125;</span>&lt;/div&gt;</span><br><span class="hljs-string">    &lt;/body&gt;</span><br><span class="hljs-string">  &lt;/html&gt;</span><br><span class="hljs-string">  `</span>;<br>  ctx.body = result;<br>&#125;);<br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;starting at port 3000&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>逻辑异常简单，①. 创建单页应用;②. vue实例转字符串;③. 拼接html并响应。</p><p><code>node ssr.js</code>，然后访问localhost:3000，我们就能如期看到页面上那个值为1的按钮了。</p><p>但这还没完事，此时点击按钮，数字是不会变化的。Vue还需要一个<strong>hydration</strong>（水合，也有人叫客户端激活）的步骤。</p><blockquote><p>所谓客户端激活，指的是 Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。</p></blockquote><p>说白了就是客户端仍然需要实例化vue app，以加载运行DOM事件等非静态代码。</p><p>hydration第一步：新增client.js。内容和上面第一步”创建单页应用“一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// client.js</span><br><span class="hljs-keyword">import</span> &#123; createSSRApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">const</span> vueApp = createSSRApp(&#123;<br>  data: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> &#125;),<br>  template: <span class="hljs-string">`&lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;`</span>,<br>&#125;);<br><br>vueApp.mount(<span class="hljs-string">&#x27;#app&#x27;</span>);<br></code></pre></td></tr></table></figure><p>hydration第二步：挂载到html。在html head中引入client.js。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/client.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>由于引入有js文件，咱们还需要启动一个静态资源服务，保证页面能加载到client.js。</p><p>完整代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Koa <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;koa&quot;</span>;<br><span class="hljs-keyword">import</span> koaStatic <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;koa-static&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; createSSRApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; renderToString &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue/server-renderer&quot;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();<br><br><span class="hljs-comment">// 静态资源中间件，确保能加载到client.js</span><br>app.use(koaStatic(<span class="hljs-string">&quot;.&quot;</span>));<br><br>app.use(<span class="hljs-keyword">async</span> (ctx) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> vueApp = createSSRApp(&#123;<br>    data: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> &#125;),<br>    template: <span class="hljs-string">`&lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;`</span>,<br>  &#125;);<br>  <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> renderToString(vueApp);<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-string">`</span><br><span class="hljs-string">  &lt;!DOCTYPE html&gt;</span><br><span class="hljs-string">  &lt;html&gt;</span><br><span class="hljs-string">  &lt;head&gt;</span><br><span class="hljs-string">    &lt;title&gt;Vue SSR Example&lt;/title&gt;</span><br><span class="hljs-string">    &lt;script type=&quot;importmap&quot;&gt;</span><br><span class="hljs-string">      &#123;</span><br><span class="hljs-string">        &quot;imports&quot;: &#123;</span><br><span class="hljs-string">          &quot;vue&quot;: &quot;https://unpkg.com/vue@3/dist/vue.esm-browser.js&quot;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">    &lt;/script&gt;</span><br><span class="hljs-string">    &lt;script type=&quot;module&quot; src=&quot;/client.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">  &lt;/head&gt;</span><br><span class="hljs-string">    &lt;body&gt;</span><br><span class="hljs-string">      &lt;div id=&quot;app&quot;&gt;<span class="hljs-subst">$&#123;html&#125;</span>&lt;/div&gt;</span><br><span class="hljs-string">    &lt;/body&gt;</span><br><span class="hljs-string">  &lt;/html&gt;</span><br><span class="hljs-string">  `</span>;<br>  ctx.body = result;<br>&#125;);<br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;starting at port 3000&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>重启服务，刷新页面，数字就能动起来了。</p><p>例子终归是例子，只是冰山一角，只是基础示意。在实际应用中还少不了，预取数据、解决状态污染、协同构建等一系列问题。总之，从头搭建一个服务端渲染的应用是相当复杂的。好在社区有成熟的SSR 解决方案，比如Vue官方推荐的Nuxt.js。</p><p><strong>备注</strong></p><p>记录一个报错。如果遇到node执行报错<code>SyntaxError: Cannot use import statement outside a module</code>，那么请升级node版本并在package.json中设置”type”: “module”。</p><blockquote><p>需要通过 <code>.mjs</code> 文件扩展名、<code>package.json</code> <a href="http://nodejs.cn/api/packages.html#type"><code>&quot;type&quot;</code></a> 字段、或 <code>--input-type</code> 标志告诉 Node.js 将 JavaScript 代码视为 ECMAScript 模块。</p></blockquote><p><strong>参考资料</strong></p><ul><li><a href="https://vuejs.org/guide/scaling-up/ssr.html">https://vuejs.org/guide/scaling-up/ssr.html</a></li><li><a href="https://juejin.cn/post/6950802238524620837#heading-2">理解Vue SSR原理，搭建项目框架</a></li><li><a href="https://www.bookstack.cn/books/vue-ssr-zh">Vue SSR 指南（Vue.js 服务器端渲染指南）</a></li></ul><h4 id="2-Web-Workers"><a href="#2-Web-Workers" class="headerlink" title="2. Web Workers"></a>2. Web Workers</h4><p><strong>概念</strong></p><blockquote><p>web worker 是运行在后台的 JavaScript，不会影响页面的性能。</p></blockquote><p>原理就是开子线程</p><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Worker"><code>Worker</code></a>接口会生成真正的操作系统级别的线程，线程可以执行任务而不阻塞 UI 线程。</p></blockquote><p>一般用于处理像密集型运算等耗费 CPU 资源的任务。</p><p><strong>实操</strong></p><p>无米之炊。我这阅历并没有遇到需要Worker的场景，仅说下自己联想到的唯二信息：①.有些插件比如psfjs有这块的应用，因为它的构建结果中有xxx.worker.js；②. Node有线程相关的API（child_process），在构建的场景有较多应用。</p><p><strong>备注</strong></p><p>列出此项与我更多的意义可能在于，时刻提醒自己：打开格局，不要思维定式。</p><p>JS是单线程的，但浏览器不是。我们是Jser，但更是Coder，不应该也不能，把自身的视野和认知仅限定在单线程或某个特定的疆域内。</p><p><strong>参考资料</strong></p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers">https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers</a></li></ul><h4 id="3-建设性能优化体系"><a href="#3-建设性能优化体系" class="headerlink" title="3. 建设性能优化体系"></a>3. 建设性能优化体系</h4><p><strong>概念</strong></p><p>自查清单只是提醒我们在开发过程中应该注意或者需要关注的一些点。如果遇到专项优化任务，那么肯定会有数值化、可验证对比等方面的要求。这时候就需要我们暂时抛开细碎的优化手段，站在更高的层级，去构建一个有目标、可验证、成体系的性能优化体系。</p><p>一般包含：指标选定、采集上报、现状分析、优化方案、测试方案、性能评估及预警等环节。</p><p><strong>实操</strong></p><p>有生之年</p><h3 id="五、写在最后"><a href="#五、写在最后" class="headerlink" title="五、写在最后"></a>五、写在最后</h3><p>本文断断续续写了1个多月，一度难产。消耗着我写作激情的同时，更是差点断送了我定期总结的大好习惯。</p><p>分析了很多原因，从思维模式到遣词造句，从人性驱动到性格剖析。在此处做个反思总结，引以为戒。</p><ol><li>目标错误，做了太多无用功。一度致力于解释为什么1+1=2，纠结于如何浅显易懂的讲解那些大家都懂得的道理；</li><li>钻了细枝末节的牛角尖。时常纠结一词一句的选用，比如该用 “应用“ 还是 ”使用“、该用逗号还是句号；</li><li>缺少遣词造句的积累。看东西时，一目十行只取其意，轮到自己表达了，绞尽脑汁生搬硬造；</li><li>逻辑思维的混乱无序。总是跳跃性的想到很多的点，然后再去归纳分类。而不是”金字塔“式的分层思考、有序表达。</li></ol><p>[苦笑]着实没什么写东西的天赋，但谁让自己喜欢呢。很认可阮一峰老师的一个观点：</p><blockquote><p>很多人建议，寻找人生方向时，你应该听从自己的内心，寻找真正热爱的事情。我现在觉得，更现实的建议应该是，寻找你愿意忍受的痛苦。 你在哪一个方向上，愿意心甘情愿地、经年累月地吃苦，具有最大的忍耐，”虽九死其尤未悔”，那就是你应该选择的方向。</p></blockquote><p>嗯，很庆幸编程和写作能成为我的方向。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我的微码</title>
    <link href="/2022/03/02/%E6%88%91%E7%9A%84%E5%BE%AE%E7%A0%81/"/>
    <url>/2022/03/02/%E6%88%91%E7%9A%84%E5%BE%AE%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="我的微码"><a href="#我的微码" class="headerlink" title="我的微码"></a>我的微码</h2><p>自己积累的一些常用代码。基于多地存储的原则，线上保存一份。</p><p>持续更新……</p><h3 id="场景篇"><a href="#场景篇" class="headerlink" title="场景篇"></a>场景篇</h3><h4 id="基于策略模式实现的表单验证类"><a href="#基于策略模式实现的表单验证类" class="headerlink" title="基于策略模式实现的表单验证类"></a>基于策略模式实现的表单验证类</h4><p>封装了常用验证规则、弹窗逻辑，易扩展、复用性强。</p><ul><li>封装表单验证类</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// validate 策略类 (设计模式之策略模式)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Validate</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.validateFuncs = [];<br>    <span class="hljs-built_in">this</span>._strategies = &#123;<br>      <span class="hljs-function"><span class="hljs-title">isNotEmpty</span>(<span class="hljs-params">value, errorMsg</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> trimedValue = <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;string&#x27;</span> ? value.trim() : value;<br>        <span class="hljs-keyword">if</span> (!trimedValue) &#123;<br>          <span class="hljs-keyword">return</span> errorMsg;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">isNotLessThan</span>(<span class="hljs-params">value, errorMsg</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> [num1, num2] = value;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Number</span>(num1) &lt; <span class="hljs-built_in">Number</span>(num2)) &#123;<br>          <span class="hljs-keyword">return</span> errorMsg;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">isNotMoreThan</span>(<span class="hljs-params">value, errorMsg</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> [num1, num2] = value;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Number</span>(num1) &gt; <span class="hljs-built_in">Number</span>(num2)) &#123;<br>          <span class="hljs-keyword">return</span> errorMsg;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">isShouldIdentilyCard</span>(<span class="hljs-params">value, errorMsg</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> idPattern =<br>          /^[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>]\d&#123;<span class="hljs-number">5</span>&#125;(<span class="hljs-number">18</span>|<span class="hljs-number">19</span>|([<span class="hljs-number">23</span>]\d))\d&#123;<span class="hljs-number">2</span>&#125;((<span class="hljs-number">0</span>[<span class="hljs-number">1</span>-<span class="hljs-number">9</span>])|(<span class="hljs-number">10</span>|<span class="hljs-number">11</span>|<span class="hljs-number">12</span>))(([<span class="hljs-number">0</span>-<span class="hljs-number">2</span>][<span class="hljs-number">1</span>-<span class="hljs-number">9</span>])|<span class="hljs-number">10</span>|<span class="hljs-number">20</span>|<span class="hljs-number">30</span>|<span class="hljs-number">31</span>)\d&#123;<span class="hljs-number">3</span>&#125;[<span class="hljs-number">0</span>-9Xx]$/;<br>        <span class="hljs-keyword">if</span> (!idPattern.test(value)) &#123;<br>          <span class="hljs-keyword">return</span> errorMsg;<br>        &#125;<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">isShouldMobileNo</span>(<span class="hljs-params">value, errorMsg</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> mobilePattern = <span class="hljs-regexp">/^1[1-9]\d&#123;9&#125;$/</span>;<br>        <span class="hljs-keyword">if</span> (!mobilePattern.test(value)) &#123;<br>          <span class="hljs-keyword">return</span> errorMsg;<br>        &#125;<br>      &#125;,<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">value, rule, errorMsg</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.validateFuncs.push(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._strategies[rule](value, errorMsg);<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">check</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; validateFuncs &#125; = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = validateFuncs.length; i &lt; len; i++) &#123;<br>      <span class="hljs-keyword">const</span> errorMsg = (<span class="hljs-function">() =&gt;</span> validateFuncs[i]())();<br>      <span class="hljs-keyword">if</span> (errorMsg) &#123;<br>        MessageBox(&#123;<br>          title: <span class="hljs-string">&#x27;温馨提示&#x27;</span>,<br>          message: errorMsg,<br>        &#125;);<br>        result = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Validate;<br></code></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> validate = <span class="hljs-keyword">new</span> Validate();<br><span class="hljs-keyword">const</span> drawMoney = <span class="hljs-built_in">Number</span>(<span class="hljs-built_in">this</span>.drawMoney);<br><span class="hljs-keyword">const</span> canDrawMaxAmount = <span class="hljs-built_in">Number</span>(<span class="hljs-built_in">this</span>.darwData.principalAmt);<br>validate.add(drawMoney, <span class="hljs-string">&quot;isNotEmpty&quot;</span>, <span class="hljs-string">&quot;请输入支取金额&quot;</span>);<br>validate.add(<br>  [drawMoney, canDrawMaxAmount],<br>  <span class="hljs-string">&quot;isNotMoreThan&quot;</span>,<br>  <span class="hljs-string">&quot;支取金额不能大于最大可支取金额&quot;</span><br>);<br><span class="hljs-keyword">if</span> (!validate.check()) &#123;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基于CSS3-var-实现的色值级主题定制"><a href="#基于CSS3-var-实现的色值级主题定制" class="headerlink" title="基于CSS3 var()实现的色值级主题定制"></a>基于CSS3 var()实现的色值级主题定制</h4><ul><li>配置项（通过接口获取）说明</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  themeColor: &#x27;#B48F4B&#x27;, // 字体、边框、背景<br>  lightBgColor: &#x27;rgba(236, 209, 157, 0.2)&#x27;, // 半透明背景<br>  gradientStartColor: &#x27;#C29B5F&#x27;, // 渐变色开始<br>  gradientEndColor: &#x27;#B48F4B&#x27;, // 渐变色结束<br>  successImg: &#x27;http://10.102.201.171:32720/uploads/-/system/user/avatar/621/avatar.png&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>实现。逻辑和样式集中放置在app.vue中，做了默认值、惰性加载、兼容手机银行类名等处理。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#x2F;&#x2F; src&#x2F;app.vue<br>&lt;template&gt;<br>  &lt;div id&#x3D;&quot;app&quot; :style&#x3D;&quot;styleVar&quot; :class&#x3D;&quot;&#123;&#39;custom&#39;:isNeedCustom&#125;&quot;&gt;<br>    &lt;router-view&gt;&lt;&#x2F;router-view&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  data () &#123;<br>    return &#123;<br>      isNeedCustom: false,<br>      &#x2F;&#x2F; 默认值<br>      styleVar: &#123;<br>        &#39;--themeColor&#39;: &#39;#176de6&#39;, &#x2F;&#x2F; 字体、边框、背景<br>        &#39;--lightBgColor&#39;: &#39;#ecf9ff&#39;,<br>        &#39;--gradientStartColor&#39;: &#39;#0173e6&#39;,<br>        &#39;--gradientEndColor&#39;: &#39;#1452cc&#39;<br>      &#125;<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    &#x2F;&#x2F; 根据渠道配置，设置自定义样式<br>    setCustomStyle (config &#x3D; &#123;&#125;) &#123;<br>      let customStyles &#x3D; &#123;&#125;<br>      const styleVar &#x3D; this.styleVar<br>      for (const key in config) &#123;<br>        const value &#x3D; config[key]<br>        const styleName &#x3D; &#96;--$&#123;key&#125;&#96;<br>        &#x2F;&#x2F; 如果有值，且是约定中的样式名<br>        if (value &amp;&amp; styleVar[styleName]) &#123;<br>          customStyles[styleName] &#x3D; value<br>        &#125;<br>      &#125;<br>      if (JSON.stringify(customStyles) &#x3D;&#x3D;&#x3D; &#39;&#123;&#125;&#39;) &#123;<br>        &#x2F;&#x2F; 只有配置了自定义样式，才会应用var变量的这套方案<br>        &#x2F;&#x2F; 否则就是全局定义的默认样式<br>        return<br>      &#125;<br>      this.styleVar &#x3D; &#123; ...styleVar, ...customStyles &#125;<br>      this.isNeedCustom &#x3D; true<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br>&lt;style lang&#x3D;&quot;less&quot;&gt;<br>&#x2F;&#x2F; 兼容框架原有换肤方案，保持与其一致的类名<br>#app.custom .dynamic-font-color &#123;<br>  color: var(--themeColor);<br>&#125;<br>#app.custom .dynamic-border-color &#123;<br>  border-color: var(--themeColor);<br>&#125;<br>#app.custom .dynamic-bg-color &#123;<br>  background-color: var(--themeColor);<br>&#125;<br>#app.custom .dynamic-bg-opacitycolor &#123;<br>  background-color: var(--lightBgColor);<br>&#125;<br>#app.custom .btn-single &#123;<br>  background: linear-gradient(<br>    to right,<br>    var(--gradientStartColor) 0%,<br>    var(--gradientEndColor) 100%<br>  );<br>&#125;<br>#app.custom .btn-half &#123;<br>  background: linear-gradient(<br>    to right,<br>    var(--gradientStartColor) 0%,<br>    var(--gradientEndColor) 100%<br>  );<br>&#125;<br>#app.custom .btn-box-half &#123;<br>  border: 1px solid var(--themeColor);<br>  color: var(--themeColor);<br>&#125;<br>#app.custom .gradient-block &#123;<br>  background: linear-gradient(<br>    to right,<br>    var(--gradientStartColor) 0%,<br>    var(--gradientEndColor) 100%<br>  );<br>&#125;<br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><ul><li>使用。获取到渠道配置后，执行app实例中的setCustomStyle方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Vue(&#123;...&#125;)<br><span class="hljs-comment">// 获取config并设置主题色           </span><br>app.$root.$children[<span class="hljs-number">0</span>].setCustomStyle(config[<span class="hljs-string">&#x27;wx&#x27;</span>])<br></code></pre></td></tr></table></figure><h4 id="曝光埋点指令"><a href="#曝光埋点指令" class="headerlink" title="曝光埋点指令"></a>曝光埋点指令</h4><ul><li>指令封装</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// plugin.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./intersection-observer.min.js&#x27;</span>;<br><br><span class="hljs-keyword">const</span> intersectionObserver = <span class="hljs-keyword">new</span> IntersectionObserver(<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">entries</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> uuId = sessionStorage.getItem(<span class="hljs-string">&#x27;uuid&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (!uuId) &#123;<br>      sessionStorage.setItem(<span class="hljs-string">&#x27;uuid&#x27;</span>, uuidv4());<br>      uuId = sessionStorage.getItem(<span class="hljs-string">&#x27;uuid&#x27;</span>);<br>    &#125;<br>    entries.forEach(<span class="hljs-function">(<span class="hljs-params">entry</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 当节点进入视窗</span><br>      <span class="hljs-keyword">if</span> (entry.isIntersecting) &#123;<br>        <span class="hljs-keyword">const</span> data = entry.target.attributes[<span class="hljs-string">&#x27;exposure-data&#x27;</span>].value;<br>        <span class="hljs-keyword">const</span> dataObJ = <span class="hljs-built_in">JSON</span>.parse(data); <br>        <span class="hljs-keyword">const</span> sendsaData = &#123;<br>          page_name: dataObJ.currentPagename || <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 所在页面</span><br>          ...<br>        &#125;;<br>        sensors.track(<span class="hljs-string">&#x27;shared_op_impression&#x27;</span>, sendsaData);<br>      &#125;<br>    &#125;);<br>  &#125;,<br>  &#123;<br>    root: <span class="hljs-literal">null</span>,<br>    rootMargin: <span class="hljs-string">&#x27;0px&#x27;</span>,<br>    threshold: <span class="hljs-number">0.5</span>, <span class="hljs-comment">// 不一定非得全部露出来  这个阈值可以小一点点</span><br>  &#125;<br>);<br><br><span class="hljs-comment">// 指令</span><br><span class="hljs-keyword">const</span> MyPlugin = &#123;<br>  install: <span class="hljs-function">(<span class="hljs-params">Vue</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 添加全局方法。会直接挂载在构造函数上</span><br>    Vue.$post = post;<br><br>    <span class="hljs-comment">// 添加实例方法。new实例化后通过this.$xxx访问</span><br>    Vue.prototype.$post = post;<br>      <br>    <span class="hljs-comment">// 全局指令-曝光埋点</span><br>    Vue.directive(<span class="hljs-string">&#x27;exposure&#x27;</span>, &#123;<br>      <span class="hljs-comment">// 当被绑定的元素插入到 DOM 中时……</span><br>      <span class="hljs-function"><span class="hljs-title">bind</span>(<span class="hljs-params">el</span>)</span> &#123;<br>        <span class="hljs-comment">// 监听元素</span><br>        intersectionObserver.observe(el);<br>      &#125;,<br>    &#125;); <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in productList&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">v-exposure</span></span><br><span class="hljs-tag">     <span class="hljs-attr">:exposure-data</span>=<span class="hljs-string">&quot;JSON.stringify(item)&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="获取验证码时的倒计时"><a href="#获取验证码时的倒计时" class="headerlink" title="获取验证码时的倒计时"></a>获取验证码时的倒计时</h4></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;span v-if&#x3D;&quot;countDownNumber&quot; class&#x3D;&quot;main__row__btn main__row__btn--waiting&quot;&gt;重新获取(&#123;&#123; countDownNumber &#125;&#125;)&lt;&#x2F;span&gt;<br>  &lt;span v-else class&#x3D;&quot;main__row__btn&quot; @click&#x3D;&quot;onSendCode()&quot;&gt;&#123;&#123;<br>    countDownNumber &#x3D;&#x3D;&#x3D; &#39;&#39; ? &#39;获取验证码&#39; : &#39;重新获取&#39;<br>    &#125;&#125;&lt;&#x2F;span&gt;<br>&lt;&#x2F;template&gt;<br>   &lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      countDownNumber: &quot;&quot;<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br>    initCountDown() &#123;<br>      clearInterval(this.timer);<br>      this.countDownNumber &#x3D; 60;<br>      this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;<br>        let count &#x3D; this.countDownNumber;<br>        count--;<br>        this.countDownNumber &#x3D; count;<br>        if (count &#x3D;&#x3D;&#x3D; 0) &#123;<br>          clearInterval(this.timer);<br>        &#125;<br>      &#125;, 1000);<br>    &#125;<br>  &#125;,<br>  destroyed() &#123;<br>    clearInterval(this.timer);<br>  &#125;<br>&#125;;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="Vue二次封装组件时，对双向绑定和属性继承的处理"><a href="#Vue二次封装组件时，对双向绑定和属性继承的处理" class="headerlink" title="Vue二次封装组件时，对双向绑定和属性继承的处理"></a>Vue二次封装组件时，对双向绑定和属性继承的处理</h4><p>纯备忘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;van-popup class&#x3D;&quot;warpper&quot; v-model&#x3D;&quot;isShowPopup&quot; position&#x3D;&quot;bottom&quot; v-bind&#x3D;&quot;$attrs&quot;&gt;<br>  &lt;&#x2F;van-popup&gt;<br>&lt;&#x2F;template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  props: &#123;<br>    visible: Boolean &#x2F;&#x2F; 显隐<br>  &#125;,<br>  computed: &#123;<br>    isShowPopup: &#123;<br>      get() &#123;<br>        return this.visible;<br>      &#125;,<br>      set(newVal) &#123;<br>        this.$emit(&quot;update:visible&quot;, newVal);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="解决VueRouter在3-0以上版本跳转与当前相同路由时报错的问题"><a href="#解决VueRouter在3-0以上版本跳转与当前相同路由时报错的问题" class="headerlink" title="解决VueRouter在3.0以上版本跳转与当前相同路由时报错的问题"></a>解决VueRouter在3.0以上版本跳转与当前相同路由时报错的问题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><span class="hljs-comment">// 解决vue-router在3.0版本以上跳转与当前路由相同路由时报错问题</span><br><span class="hljs-keyword">const</span> originalPush = VueRouter.prototype.push;<br>VueRouter.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">location, onResolve, onReject</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (onResolve || onReject) <span class="hljs-keyword">return</span> originalPush.call(<span class="hljs-built_in">this</span>, location, onResolve, onReject);<br>  <span class="hljs-keyword">return</span> originalPush.call(<span class="hljs-built_in">this</span>, location).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (VueRouter.isNavigationFailure(err)) &#123;<br>      <span class="hljs-comment">// resolve err</span><br>      <span class="hljs-keyword">return</span> err;<br>    &#125;<br>    <span class="hljs-comment">// rethrow error</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(err);<br>  &#125;);<br>&#125;;<br>Vue.use(VueRouter);<br></code></pre></td></tr></table></figure><h4 id="VueRouter路由切换时自动滚动到顶部"><a href="#VueRouter路由切换时自动滚动到顶部" class="headerlink" title="VueRouter路由切换时自动滚动到顶部"></a>VueRouter路由切换时自动滚动到顶部</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// router.js</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  routes: [],<br>  <span class="hljs-function"><span class="hljs-title">scrollBehavior</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> &#125;;<br>  &#125;<br>&#125;);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><h4 id="重载Vue页面"><a href="#重载Vue页面" class="headerlink" title="重载Vue页面"></a>重载Vue页面</h4><ul><li><p>方案1(推荐)</p><p>如果是在js中使用，可以把reload挂载到window；如果是在vue组件内使用，可以使用依赖注入</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div id&#x3D;&quot;app&quot;&gt;<br>    &lt;router-view v-if&#x3D;&quot;isRouterAlive&quot;&gt;&lt;&#x2F;router-view&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    &#x2F;&#x2F; 加挂全局的vue对象,用于手机银行重新登陆后的页面重载<br>    window.$appVue &#x3D; this;<br>    return &#123;<br>      isRouterAlive: true<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br>    reload() &#123;<br>      this.isRouterAlive &#x3D; false;<br>      this.$nextTick(() &#x3D;&gt; &#123;<br>        this.isRouterAlive &#x3D; true;<br>      &#125;);<br>    &#125;<br>  &#125;<br>&#125;;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><ul><li>方案2</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reloadPage</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// window.$appVue.$router.go(0) // location.reload方案在APP无效</span><br>  <span class="hljs-keyword">const</span> path = <span class="hljs-built_in">window</span>.$appVue.$route.fullPath;<br>  <span class="hljs-built_in">window</span>.$appVue.$router.replace(<span class="hljs-string">&#x27;/&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">window</span>.$appVue.$router.replace(path);<br>  &#125;, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="axios二次封装，保证并行请求仅有1个loading"><a href="#axios二次封装，保证并行请求仅有1个loading" class="headerlink" title="axios二次封装，保证并行请求仅有1个loading"></a>axios二次封装，保证并行请求仅有1个loading</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// http.js</span><br><span class="hljs-keyword">let</span> requestNum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 带loading的请求数量，保证并行请求仅有1个loading</span><br><span class="hljs-keyword">let</span> isLoading = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showLoading</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!isLoading) &#123;<br>    sirius.showLoading();<br>    isLoading = <span class="hljs-literal">true</span>;<br>  &#125;<br>  requestNum++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hideLoading</span>(<span class="hljs-params"></span>) </span>&#123;<br>  requestNum--;<br>  <span class="hljs-keyword">if</span> (requestNum &lt;= <span class="hljs-number">0</span>) &#123;<br>    sirius.hideLoading();<br>    isLoading = <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> post = <span class="hljs-function">(<span class="hljs-params">needLoading = <span class="hljs-literal">true</span></span>) =&gt;</span> &#123;<br>  needLoading &amp;&amp; showLoading();<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    axios().then(<span class="hljs-function">()=&gt;</span>&#123;<br>      resolve()<br>      needLoading &amp;&amp; hideLoading();<br>    &#125;).catch(<span class="hljs-function">()=&gt;</span>&#123;<br>      reject()<br>      needLoading &amp;&amp; hideLoading();<br>    &#125;)<br>  &#125;);<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> post;<br></code></pre></td></tr></table></figure><h4 id="判断首次进入页面"><a href="#判断首次进入页面" class="headerlink" title="判断首次进入页面"></a>判断首次进入页面</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 初次进入清除tokne的判断：有accesstoken，且不是单页应用内后退，且不是刷新</span><br>  <span class="hljs-comment">// window.performance.navigation.type判断页面加载来源  0跳转 1刷新 2后退</span><br>  <span class="hljs-keyword">if</span> (accesstoken &amp;&amp; <span class="hljs-keyword">from</span>.name === <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">window</span>.performance.navigation.type === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">window</span>.localStorage.removeItem(<span class="hljs-string">&#x27;sessions&#x27;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="监听页面显隐事件"><a href="#监听页面显隐事件" class="headerlink" title="监听页面显隐事件"></a>监听页面显隐事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&quot;visibilitychange&quot;</span>, <span class="hljs-built_in">this</span>.onVisibilityChange);<br>  &#125;,<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">onVisibilityChange</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.visibilityState === <span class="hljs-string">&quot;visible&quot;</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;***页面可见***&quot;</span>);<br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">destroyed</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">&quot;visibilitychange&quot;</span>, <span class="hljs-built_in">this</span>.onVisibilityChange);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="解决滚动穿透"><a href="#解决滚动穿透" class="headerlink" title="解决滚动穿透"></a>解决滚动穿透</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 解决滚动穿透</span><br>$(<span class="hljs-string">&#x27;.box&#x27;</span>).on(<span class="hljs-string">&#x27;touchmove&#x27;</span>, <span class="hljs-string">&#x27;.box-bg&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>e.preventDefault();<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h3><h4 id="扩展toFixed，以解决四舍五入不准确的问题"><a href="#扩展toFixed，以解决四舍五入不准确的问题" class="headerlink" title="扩展toFixed，以解决四舍五入不准确的问题"></a>扩展toFixed，以解决四舍五入不准确的问题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.Number.prototype.toFixed = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">d</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> s = <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>&#125;</span>`</span>;<br>  <span class="hljs-keyword">if</span> (!d) d = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (s.indexOf(<span class="hljs-string">&#x27;.&#x27;</span>) === -<span class="hljs-number">1</span>) s += <span class="hljs-string">&#x27;.&#x27;</span>;<br>  s += <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(d + <span class="hljs-number">1</span>).join(<span class="hljs-string">&#x27;0&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`^(-|\\+)?(\\d+(\\.\\d&#123;0,<span class="hljs-subst">$&#123;d + <span class="hljs-number">1</span>&#125;</span>&#125;)?)\\d*$`</span>).test(s)) &#123;<br>    <span class="hljs-keyword">let</span> s2 = <span class="hljs-string">`0<span class="hljs-subst">$&#123;<span class="hljs-built_in">RegExp</span>.$<span class="hljs-number">2</span>&#125;</span>`</span>;<br>    <span class="hljs-keyword">const</span> pm = <span class="hljs-built_in">RegExp</span>.$1;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">RegExp</span>.$3.length;<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (a === d + <span class="hljs-number">2</span>) &#123;<br>      a = s2.match(<span class="hljs-regexp">/\d/g</span>);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(a[a.length - <span class="hljs-number">1</span>]) &gt; <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = a.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>          a[i] = <span class="hljs-built_in">parseInt</span>(a[i]) + <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">if</span> (a[i] === <span class="hljs-number">10</span>) &#123;<br>            a[i] = <span class="hljs-number">0</span>;<br>            b = i !== <span class="hljs-number">1</span>;<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>      s2 = a.join(<span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`(\\d+)(\\d&#123;<span class="hljs-subst">$&#123;d&#125;</span>&#125;)\\d$`</span>), <span class="hljs-string">&#x27;$1.$2&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (b) s2 = s2.substr(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> (pm + s2).replace(<span class="hljs-regexp">/\.$/</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>&#125;</span>`</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="封装sessionStroage，使支持对json的存取"><a href="#封装sessionStroage，使支持对json的存取" class="headerlink" title="封装sessionStroage，使支持对json的存取"></a>封装sessionStroage，使支持对json的存取</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> saveJsonToSession = <span class="hljs-function">(<span class="hljs-params">key, data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> str = <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;string&#x27;</span> ? data : <span class="hljs-built_in">JSON</span>.stringify(data);<br>  <span class="hljs-built_in">window</span>.sessionStorage.setItem(key, str);<br>&#125;;<br><br><span class="hljs-keyword">const</span> getJsonFromSession = <span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> stringData = <span class="hljs-built_in">window</span>.sessionStorage.getItem(key);<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">if</span> (stringData) &#123;<br>    result = stringData.startsWith(<span class="hljs-string">&#x27;&#123;&#x27;</span>) || stringData.startsWith(<span class="hljs-string">&#x27;[&#x27;</span>) ? <span class="hljs-built_in">JSON</span>.parse(stringData) : stringData;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="浮点数四则运算"><a href="#浮点数四则运算" class="headerlink" title="浮点数四则运算"></a>浮点数四则运算</h4><p>解决js浮点数运算不准确的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 浮点数计算相加兼容</span><br><span class="hljs-keyword">const</span> floatAdd = <span class="hljs-function">(<span class="hljs-params">num1, num2</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> r1, r2;<br>  <span class="hljs-keyword">try</span> &#123;<br>    r1 = num1.toString().split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>].length;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    r1 = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">try</span> &#123;<br>    r2 = num2.toString().split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>].length;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    r2 = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> m = <span class="hljs-number">10</span> ** <span class="hljs-built_in">Math</span>.max(r1, r2);<br>  <span class="hljs-keyword">const</span> n = r1 &gt;= r2 ? r1 : r2;<br>  <span class="hljs-keyword">return</span> ((num1 * m + num2 * m) / m).toFixed(n);<br>&#125;;<br><span class="hljs-comment">// 浮点相减bug兼容</span><br><span class="hljs-keyword">const</span> floatSub = <span class="hljs-function">(<span class="hljs-params">num1, num2</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> r1, r2;<br>  <span class="hljs-keyword">try</span> &#123;<br>    r1 = num1.toString().split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>].length;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    r1 = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">try</span> &#123;<br>    r2 = num2.toString().split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>].length;<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    r2 = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> m = <span class="hljs-number">10</span> ** <span class="hljs-built_in">Math</span>.max(r1, r2);<br>  <span class="hljs-keyword">const</span> n = r1 &gt;= r2 ? r1 : r2;<br>  <span class="hljs-keyword">return</span> ((num1 * m - num2 * m) / m).toFixed(n);<br>&#125;;<br><span class="hljs-comment">// js 浮点数计算 乘</span><br><span class="hljs-keyword">const</span> floatMul = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> c = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> d = a.toString();<br>  <span class="hljs-keyword">const</span> e = b.toString();<br>  <span class="hljs-keyword">const</span> dDecimals = d.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">const</span> eDecimals = e.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">if</span> (dDecimals) &#123;<br>    c += dDecimals.length;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (eDecimals) &#123;<br>    c += eDecimals.length;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">Number</span>(d.replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)) * <span class="hljs-built_in">Number</span>(e.replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))) / <span class="hljs-number">10</span> ** c;<br>&#125;;<br><span class="hljs-comment">// 浮点数相除问题</span><br><span class="hljs-keyword">const</span> floatDiv = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> c = <span class="hljs-built_in">Number</span>(a.toString().replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>));<br>  <span class="hljs-keyword">const</span> d = <span class="hljs-built_in">Number</span>(b.toString().replace(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>));<br>  <span class="hljs-keyword">const</span> aDecimals = a.toString().split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">const</span> bDecimals = b.toString().split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">const</span> e = aDecimals ? aDecimals.length : <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> f = bDecimals ? bDecimals.length : <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> floatMul(c / d, <span class="hljs-number">10</span> ** (f - e));<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="防抖-节流函数"><a href="#防抖-节流函数" class="headerlink" title="防抖/节流函数"></a>防抖/节流函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 防抖功能函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, timestamp = <span class="hljs-number">1000</span></span>) </span>&#123;<br>  <span class="hljs-comment">// 1、创建一个标记用来存放定时器的返回值</span><br>  <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-comment">// 2、每次当用户点击/输入的时候，把前一个定时器清除</span><br>    <span class="hljs-built_in">clearTimeout</span>(timeout);<br>    <span class="hljs-comment">// 3、然后创建一个新的 setTimeout，</span><br>    <span class="hljs-comment">// 这样就能保证点击按钮后的 interval 间隔内</span><br>    <span class="hljs-comment">// 如果用户还点击了的话，就不会执行 fn 函数</span><br>    timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.call(<span class="hljs-built_in">this</span>, args);<br>    &#125;, timestamp);<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 节流函数,立即执行版</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, timestamp = <span class="hljs-number">1000</span></span>) </span>&#123;<br>  <span class="hljs-comment">// 1、通过闭包保存一个标记</span><br>  <span class="hljs-keyword">let</span> canRun = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-comment">// 2、在函数开头判断标志是否为 true，不为 true 则中断函数</span><br>    <span class="hljs-keyword">if</span> (!canRun) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 3、将 canRun 设置为 false，防止执行之前再被执行</span><br>    canRun = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 4、定时器</span><br>    fn.call(<span class="hljs-built_in">this</span>, args);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// fn.call(this, arguments);</span><br>      <span class="hljs-comment">// 5、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true</span><br>      canRun = <span class="hljs-literal">true</span>;<br>    &#125;, timestamp);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="金额转汉字"><a href="#金额转汉字" class="headerlink" title="金额转汉字"></a>金额转汉字</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 金额大写</span><br>Vue.filter(<span class="hljs-string">&#x27;amount&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">input</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (input !== <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">const</span> intPosTwo = input.indexOf(<span class="hljs-string">&#x27;,&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (intPosTwo) &#123;<br>      input = input.replace(<span class="hljs-regexp">/,/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseFloat</span>(input) &lt; <span class="hljs-number">0</span> || <span class="hljs-built_in">isNaN</span>(input) || input === <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;零元整&#x27;</span>;<br>    &#125;<br>    input = <span class="hljs-built_in">String</span>(<span class="hljs-built_in">parseFloat</span>(input));<br>    <span class="hljs-keyword">let</span> strOutput = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">let</span> strUnit = <span class="hljs-string">&#x27;仟佰拾万仟佰拾亿仟佰拾万仟佰拾元角分&#x27;</span>;<br>    input += <span class="hljs-string">&#x27;00&#x27;</span>;<br>    <span class="hljs-keyword">const</span> intPos = input.indexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (intPos &gt;= <span class="hljs-number">0</span>) &#123;<br>      input = input.substring(<span class="hljs-number">0</span>, intPos) + input.substr(intPos + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    &#125;<br>    strUnit = strUnit.substr(strUnit.length - input.length);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; input.length; i++) &#123;<br>      strOutput += <span class="hljs-string">&#x27;零壹贰叁肆伍陆柒捌玖&#x27;</span>.substr(input.substr(i, <span class="hljs-number">1</span>), <span class="hljs-number">1</span>) + strUnit.substr(i, <span class="hljs-number">1</span>);<br>    &#125;<br>    strOutput = strOutput<br>      .replace(<span class="hljs-regexp">/零角零分$/</span>, <span class="hljs-string">&#x27;整&#x27;</span>)<br>      .replace(<span class="hljs-regexp">/零[仟佰拾]/g</span>, <span class="hljs-string">&#x27;零&#x27;</span>)<br>      .replace(<span class="hljs-regexp">/零&#123;2,&#125;/g</span>, <span class="hljs-string">&#x27;零&#x27;</span>)<br>      .replace(<span class="hljs-regexp">/零([亿|万])/g</span>, <span class="hljs-string">&#x27;$1&#x27;</span>)<br>      .replace(<span class="hljs-regexp">/零+元/</span>, <span class="hljs-string">&#x27;元&#x27;</span>)<br>      .replace(<span class="hljs-regexp">/亿零&#123;0,3&#125;万/</span>, <span class="hljs-string">&#x27;亿&#x27;</span>)<br>      .replace(<span class="hljs-regexp">/^元/</span>, <span class="hljs-string">&#x27;零元&#x27;</span>)<br>      .replace(<span class="hljs-regexp">/零角/</span>, <span class="hljs-string">&#x27;零&#x27;</span>)<br>      .replace(<span class="hljs-regexp">/零分/</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseFloat</span>(input) === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;零元整&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseFloat</span>(input) &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">parseFloat</span>(input) &lt; <span class="hljs-number">100</span>) &#123;<br>      <span class="hljs-keyword">return</span> strOutput.replace(<span class="hljs-regexp">/零元/</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-regexp">/零/</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> strOutput;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;零元&#x27;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>入门即巅峰，Vue3.0学习总结之响应式API</title>
    <link href="/2021/12/23/%E5%85%A5%E9%97%A8%E5%8D%B3%E5%B7%85%E5%B3%B0%EF%BC%8CVue3.0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8FAPI/"/>
    <url>/2021/12/23/%E5%85%A5%E9%97%A8%E5%8D%B3%E5%B7%85%E5%B3%B0%EF%BC%8CVue3.0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8FAPI/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写作就像开源，即渡人也渡己。 –码农胖大海</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>先赞后看，已成习惯。大家好，我是在编程世界里苟且偷生的大海。</p><p>本文旨在通俗易懂的描述“响应式API”的概念、作用和语法，作为自己学习的延续和阶段性成果展示。</p><h3 id="一、什么是响应性API"><a href="#一、什么是响应性API" class="headerlink" title="一、什么是响应性API"></a>一、什么是响应性API</h3><ol><li><p>在描述概念之前，先来回顾一下，什么是响应性。</p><blockquote><p>响应性是一种允许我们以声明式的方式去适应变化的编程范例。</p></blockquote><p>适应变化？还是很懵……先来看一个非响应性的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> val1 = <span class="hljs-number">2</span><br><span class="hljs-keyword">let</span> val2 = <span class="hljs-number">3</span><br><span class="hljs-keyword">let</span> sum = val1 + val2<br><span class="hljs-built_in">console</span>.log(sum) <span class="hljs-comment">// 5</span><br>val1 = <span class="hljs-number">3</span><br><span class="hljs-built_in">console</span>.log(sum) <span class="hljs-comment">// 仍然是 5</span><br></code></pre></td></tr></table></figure><p>我们改变了第一个值，sum的值并没有改变。</p><p>相反，如果改变一个值，sum被重新计算和赋值了，那么这就是响应性的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      val1:<span class="hljs-number">2</span>,<br>      val2:<span class="hljs-number">3</span><br>    &#125;<br>  &#125;,<br>  computed:&#123;<br>    <span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.val1 + <span class="hljs-built_in">this</span>.val2<br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.sum) <span class="hljs-comment">// 5</span><br>    <span class="hljs-built_in">this</span>.val1 = <span class="hljs-number">3</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.sum) <span class="hljs-comment">// 6 sum会随着改变</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Vue中的响应性</p><p>上面例子中用到的computed计算属性，就是Vue对响应性的一种实现。</p><p>除此之外，响应性在Vue中还通常表现为：改变绑定在模板上的数据，视图会自动更新。这就是 Vue引以为傲的“响应性系统”，也是Web前端由“操作DOM”到“数据驱动”巨大变革的基石。</p><p>至于它是如何实现的？这是一个耳熟能详、老生常谈的面试题，“介绍一下Vue的响应式原理”。</p></li><li><p>在回答完什么是响应性后，什么是响应式API也就不言自喻了<br>响应式API是Vue3.0新增的，为 JavaScript 对象创建响应式状态/效果的一系列函数/方法的总称。核心语法包括reactive、ref、coumpetd、watch等</p></li></ol><h3 id="二、核心语法介绍"><a href="#二、核心语法介绍" class="headerlink" title="二、核心语法介绍"></a>二、核心语法介绍</h3><h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive()"></a>reactive()</h4><ol><li><p>该 API 返回一个响应式的对象状态。使我们可以显式的定义一个响应式状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">// 响应式状态</span><br><span class="hljs-keyword">const</span> state = reactive(&#123;<br>  count: <span class="hljs-number">0</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(state) <span class="hljs-comment">// Proxy &#123;count: 0&#125;</span><br></code></pre></td></tr></table></figure><p>把响应式的对象绑定到模板上，数据变化时，视图就会自动更新。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">state</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>该响应式转换是“深度转换”——它会影响传递对象的所有嵌套 property。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = reactive(&#123;<br>  obj: &#123;<br>  count1: <span class="hljs-number">0</span>, <span class="hljs-comment">// 注意，比上面多了一层嵌套</span><br>  &#125;<br>&#125;)<br><span class="hljs-comment">// state.obj.count1 也是响应式的</span><br></code></pre></td></tr></table></figure></li><li><p>我们定义在data选项中的数据，其响应性也是由 <code>reactive()</code> 实现的。</p><blockquote><p>当从组件中的 <code>data()</code> 返回一个对象时，它在内部交由 <code>reactive()</code> 使其成为响应式对象。</p></blockquote></li><li><p>基于Proxy跟踪数据变化，避免了 Vue 早期版本中存在的响应性失效问题。<br>由于 JavaScript 的限制（Object.defineProperty），Vue <strong>不能检测</strong>数组和对象的变化。响应性在以下场景会失效：</p><ul><li>当添加或移除对象属性时</li><li>当利用索引直接设置一个数组项时</li><li>当修改数组的长度时</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  data: &#123;<br>    a: <span class="hljs-number">1</span><br>  &#125;<br>&#125;)<br><span class="hljs-comment">// `vm.a` 现在是响应式的</span><br><br>vm.b = <span class="hljs-number">2</span><br><span class="hljs-comment">// `vm.b` 不是响应式的</span><br></code></pre></td></tr></table></figure><p>Vue3.0改用ES6的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> 跟踪数据变化，避免了上述问题。如果打印reactive函数的返回，可以明显看到它是一个Proxy对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = reactive(&#123;<br>  count: <span class="hljs-number">0</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(state) <span class="hljs-comment">// Proxy &#123;count: 0&#125;</span><br></code></pre></td></tr></table></figure><p>至于，为什么Object.defineProperty的方案有缺陷，以及为什么Proxy能避免这个问题并有着更好的性能，之前在<a href="https://juejin.cn/post/6940559895330717709">《一文读懂Vue3的改进与优化》</a>中有详细描述，在此就不赘述了。</p></li></ol><h4 id="ref"><a href="#ref" class="headerlink" title="ref()"></a>ref()</h4><ol><li><p>接受一个内部值并返回一个响应式且可变的 ref 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">let</span> count = ref(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">console</span>.log(count); <span class="hljs-comment">// RefImpl &#123;_shallow: false, dep: undefined, __v_isRef: true, _rawValue: 1, _value: 1&#125;</span><br></code></pre></td></tr></table></figure><p>对，它和<code>reactive()</code>一样，都能创建响应式对象。区别在于ref可以接受基础类型的值，而reactive不可以。</p></li><li><p>如果接受的值是一个对象，那么它将被 <a href="https://v3.cn.vuejs.org/api/basic-reactivity.html#reactive">reactive</a> 函数处理为深层的响应式对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> refObj = ref(&#123;<br>  count:<span class="hljs-string">&#x27;1&#x27;</span>,<br>&#125;)<br><span class="hljs-built_in">console</span>.log(refObj.value) <span class="hljs-comment">// Proxy &#123;count: &#x27;1&#x27;&#125;</span><br></code></pre></td></tr></table></figure><p>此时<code>ref(obj).value</code> 等效于 <code>reactive(obj)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  count:<span class="hljs-string">&#x27;1&#x27;</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(ref(obj).value === reactive(obj)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p>在setup函数中，需要通过.value属性访问和改变它的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> count = ref(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">console</span>.log(count.value); <span class="hljs-comment">// 1</span><br>count.value = <span class="hljs-number">2</span><br><span class="hljs-built_in">console</span>.log(count.value); <span class="hljs-comment">// 2</span><br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>在模板中访问则不需要，Vue会自动对Ref 进行解包</p><blockquote><p>当 ref 作为渲染上下文 (从 <a href="https://v3.cn.vuejs.org/guide/composition-api-setup.html">setup()</a> 中返回的对象) 上的 property 返回并可以在模板中被访问时，它将自动浅层次解包内部值。只有访问嵌套的 ref 时需要在模板中添加 <code>.value</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &#x2F;&#x2F; 不需要.value<br>    &lt;span&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;span&gt;<br>    &lt;button @click&#x3D;&quot;count ++&quot;&gt;Increment count&lt;&#x2F;button&gt;<br>    &#x2F;&#x2F; 需要.value<br>    &lt;button @click&#x3D;&quot;nested.count.value ++&quot;&gt;Nested Increment count&lt;&#x2F;button&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>  import &#123; ref &#125; from &#39;vue&#39;<br>  export default &#123;<br>    setup() &#123;<br>      const count &#x3D; ref(0)<br>      return &#123;<br>        count,<br>        nested: &#123;<br>          count<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure></li></ol><h4 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs()"></a>toRefs()</h4><p>说白了就是，响应式对象版的 解构赋值。它使我们可以像使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">ES6 解构</a>那样，来获取我们想要的<strong>响应式对象</strong>的属性，且不失去响应性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">const</span> state = reactive(&#123;<br>  foo: <span class="hljs-number">1</span>,<br>  bar: <span class="hljs-number">2</span><br>&#125;)<br>  <span class="hljs-comment">// 可以在不失去响应性的情况下解构</span><br>  <span class="hljs-keyword">const</span> &#123; foo, bar &#125; = toRefs(state)<br>  <span class="hljs-keyword">return</span> &#123;<br>    foo,<br>    bar<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>像这样辅助类的响应式API还有很多，比如使用 <code>readonly</code> 防止更改响应式对象、使用<code>isRef</code>检查值是否为一个 ref 对象等等，就不一一介绍了。</p><p>原因有二，①仅使用reactive和ref就能满足大多数的应用场景，延后学习，并不妨碍我们“入门”和做项目；②这类API加起来有十来个，需要消耗不少的精力和注意力，放在入门阶段去啃，凭空增加入门难度。</p><p>凡事有个主次，我们大可以走马观花的过一遍API，大致有个印象，等将来用到了再回来补课。</p><h4 id="computed"><a href="#computed" class="headerlink" title="computed()"></a>computed()</h4><p>同选项式API中的computed</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = ref(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> plusOne = computed(<span class="hljs-function">() =&gt;</span> count.value + <span class="hljs-number">1</span>)<br><span class="hljs-built_in">console</span>.log(plusOne.value) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h4 id="watch"><a href="#watch" class="headerlink" title="watch()"></a>watch()</h4><p>同选项式API中的watch</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; onMounted, ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-comment">// setup中的watch函数，等效选项式API中的watch</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props, context</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> defaultName = ref(<span class="hljs-string">&quot;码农胖大海&quot;</span>);<br>    onMounted(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;mounted!&quot;</span>);<br>      <span class="hljs-comment">// 更新数据以触发watch</span><br>      defaultName.value = <span class="hljs-string">&quot;mounted后的大海&quot;</span>;<br>    &#125;);<br>    watch(defaultName, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;The defaultName is: &quot;</span> + defaultName.value); <span class="hljs-comment">// The defaultName is: mounted后的大海</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;The defaultName newValue is: &quot;</span> + newValue); <span class="hljs-comment">// The defaultName newValue is: mounted后的大海</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;The defaultName oldValue is: &quot;</span> + oldValue); <span class="hljs-comment">// The defaultName oldValue is: 码农胖大海</span><br>    &#125;);<br>    <span class="hljs-keyword">return</span> &#123;<br>      defaultName,<br>    &#125;;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>响应式API可以看做是复合式API的延续，他们是一体的。只是Vue从功能作用上把他们分为了两大类。</p><p>这是《入门即巅峰，Vue3.0学习总结》的第三篇。</p><ol><li><p><a href="https://juejin.cn/post/6940559895330717709">入门即巅峰，一文读懂Vue3.0的改进与优化</a>  </p></li><li><p><a href="https://juejin.cn/post/7041843727958507528">入门即巅峰，Vue3.0学习总结之复合式API</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>入门即巅峰，Vue3.0学习总结之复合式API</title>
    <link href="/2021/12/14/%E5%85%A5%E9%97%A8%E5%8D%B3%E5%B7%85%E5%B3%B0%EF%BC%8CVue3.0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%A4%8D%E5%90%88%E5%BC%8FAPI/"/>
    <url>/2021/12/14/%E5%85%A5%E9%97%A8%E5%8D%B3%E5%B7%85%E5%B3%B0%EF%BC%8CVue3.0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E5%A4%8D%E5%90%88%E5%BC%8FAPI/</url>
    
    <content type="html"><![CDATA[<blockquote><p>写作是对自己思想的开发和研究。</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>先赞后看，已成习惯。大叫好我是奉旨撸码的胖大海。<br>本文旨在通俗易懂的描述“复合式API”的概念、语法和作用，作为自己学习的延续和阶段性成果展示。</p><h3 id="一、什么是复合式API？"><a href="#一、什么是复合式API？" class="headerlink" title="一、什么是复合式API？"></a>一、什么是复合式API？</h3><p>复合式API是Vue3.0新增的、相对于”选项式API“而言的，一种新的组件编写形式。语法层面，主要由setup函数和在其内部调用的生命周期钩子构成，使用时一般还会搭配一些响应式API（下期内容）。</p><ul><li><p>setup函数<br>组合式 API 的入口，一般做为组件选项使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  props: &#123;<br>    name: &#123;<br>      type: <span class="hljs-built_in">String</span>,<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props,context</span>)</span> &#123;<br>    <span class="hljs-comment">// setup 选项是一个接收 props 和 context 的函数</span><br>    <span class="hljs-built_in">console</span>.log(props); <span class="hljs-comment">// &#123; name: &#x27;&#x27; &#125;</span><br>    <span class="hljs-keyword">const</span> defaultName = props.name||<span class="hljs-string">&#x27;码农胖大海&#x27;</span><br>    <span class="hljs-comment">// 这里返回的任何内容可以用于组件的其余部分，模板以及refs获取组件实例后的访问</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      defaultName<br>    &#125;;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>需要注意的是在 setup 中你应该避免使用 this，因为setup 选项在组件创建之前执行，此时组件实例还没有生产。</p></li><li><p>生命周期钩子<br>可以通过直接导入 <code>onX</code> 函数来注册生命周期钩子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; onMounted, onUpdated, onUnmounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> MyComponent = &#123;<br>  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;<br>    onMounted(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;mounted!&#x27;</span>)<br>    &#125;)<br>    onUpdated(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;updated!&#x27;</span>)<br>    &#125;)<br>    onUnmounted(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;unmounted!&#x27;</span>)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和Vue的生命周期是一致的，除了create，因为setup本身就是这个阶段。</p><p>详情可以参看<a href="https://v3.cn.vuejs.org/api/composition-api.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><strong>选项式 API 的生命周期选项和组合式 API 之间的映射</strong></a></p></li><li><p><code>&lt;script setup&gt;</code></p><p>Vue3.2新增的复合式API新写法，是在单文件组件中使用组合式 API 的编译时语法糖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>console.log(&#39;hello script setup&#39;)<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>里面的代码会被编译成组件 <code>setup()</code> 函数的内容，在每次组件实例被创建的时候执行。内置有<code>defineProps</code> 、 <code>defineEmits</code>等方法，以提供和setup()函数中props和context相似的能力。</p><p>其间定义的所有变量都可以直接在模板使用，包括improt导入的组件或方法（官方：顶层的绑定会被暴露给模板）。但是，当需要通过模板 ref 或者 $parent访问该组件实例时，需要使用defineExpose明确要暴露出去的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class&#x3D;&quot;c-count-wrap&quot;&gt;<br>    &lt;span class&#x3D;&quot;c-count-num&quot;&gt;&#123;&#123; currentTime &#125;&#125;&lt;&#x2F;span&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script setup&gt;<br>let currentTime &#x3D; ref(props.initialValue);<br>let timer &#x3D; null; &#x2F;&#x2F; 定时器<br><br>&#x2F;&#x2F; ...省略很多代码，具体的参看最后一个例子<br>const stop &#x3D; () &#x3D;&gt; &#123;<br>  clearInterval(timer);<br>&#125;;<br><br>&#x2F;&#x2F; 使用defineExpose明确要暴露出去的属性和方法<br>defineExpose(&#123;<br>  stop,<br>&#125;);<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>相比于普通的 script 语法，它具有更多优势：</p><blockquote><ul><li>更少的样板内容，更简洁的代码。</li><li>能够使用纯 Typescript 声明 props 和抛出事件。</li><li>更好的运行时性能 (其模板会被编译成与其同一作用域的渲染函数，没有任何的中间代理)。</li><li>更好的 IDE 类型推断性能 (减少语言服务器从代码中抽离类型的工作)。</li></ul></blockquote></li></ul><h3 id="二、它的出现是为了解决什么问题？"><a href="#二、它的出现是为了解决什么问题？" class="headerlink" title="二、它的出现是为了解决什么问题？"></a>二、它的出现是为了解决什么问题？</h3><p>可以帮助我们<strong>更好的</strong>进行代码逻辑的<strong>聚合</strong>和<strong>复用</strong>。</p><p>当一个组件包含功能较多，变得越来越复杂的时候，选项式API的方式有一个弊端。它会导致逻辑关注点分散，继而使得理解和维护组件变得困难。官方文档中的这个大型组件的示例，很好的展示了这点（图中逻辑关注点按颜色进行了分组）。</p><p><img src="http://7niu.zhaohaipeng.com/62783021-7ce24400-ba89-11e9-9dd3-36f4f6b1fae2.png" alt="Vue 选项式 API: 按选项类型分组的代码"></p><p>复合式API允许我们将这些分散在data、computed、methods、filters……中的相关逻辑拎出来写在一起，以实现代码逻辑的聚合和复用。类似mixins，但比mixins要灵活，且没有变量覆盖、数据来源不明的问题。</p><h3 id="三、举个例子"><a href="#三、举个例子" class="headerlink" title="三、举个例子"></a>三、举个例子</h3><p>通过一个例子感受下“选项式”和“复合式”的区别。</p><p>这里拿很久之前实现过的倒计时组件举例。代码做了简化，但麻雀虽小，五脏俱全，非常适合练手。<a href="https://github.com/qq9694526/vue3-study">Github上有完整代码</a></p><p><img src="http://7niu.zhaohaipeng.com/image-20211211172627033.png" alt="image-20211211172627033"></p><p>模板部分很简单，由两个颜色的svg图片和中间的数字构成。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c-count-wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/200/svg&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;110&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;110&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;55&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;55&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;none&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;#ccc&quot;</span> <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">stroke-linecap</span>=<span class="hljs-string">&quot;round&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c-count-process&quot;</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;55&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;55&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;none&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;#ff9800&quot;</span> <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">:stroke-dasharray</span>=<span class="hljs-string">&quot;`$&#123;process&#125;,10000`&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;c-count-num&quot;</span>&gt;</span>&#123;&#123; currentTime &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>.c-count-wrap &#123;<br><span class="css">  <span class="hljs-attribute">display</span>: inline-block;</span><br><span class="css">  <span class="hljs-attribute">position</span>: relative;</span><br><span class="css">  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;</span><br>&#125;<br>.c-count-wrap .c-count-num &#123;<br><span class="css">  <span class="hljs-attribute">position</span>: absolute;</span><br><span class="css">  <span class="hljs-attribute">display</span>: inline-block;</span><br><span class="css">  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;</span><br><span class="css">  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">  <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">50%</span>);</span><br><span class="css">  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;</span><br><span class="css">  <span class="hljs-attribute">white-space</span>: nowrap;</span><br>&#125;<br>.c-count-wrap .c-count-process &#123;<br><span class="css">  <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">55px</span> <span class="hljs-number">55px</span>;</span><br><span class="css">  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(-<span class="hljs-number">90deg</span>);</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Js部分则是有2个入参、1个计算属性、3个方法和1个事件。</p><h4 id="选项式API的实现"><a href="#选项式API的实现" class="headerlink" title="选项式API的实现"></a>选项式API的实现</h4><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    initialValue: &#123;</span><br><span class="xml">      type: Number,</span><br><span class="xml">      default: 10,</span><br><span class="xml">    &#125;,</span><br><span class="xml">    autoPlay: &#123;</span><br><span class="xml">      type: Boolean,</span><br><span class="xml">      default: true,</span><br><span class="xml">    &#125;,</span><br><span class="xml">  &#125;,</span><br><span class="xml">  data() &#123;</span><br><span class="xml">    return &#123;</span><br><span class="xml">      currentTime: 0,</span><br><span class="xml">      timer: null,</span><br><span class="xml">    &#125;;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  computed: &#123;</span><br><span class="xml">  // 环形进度条</span><br><span class="xml">    process() &#123;</span><br><span class="xml">      const totalTime = this.initialValue;</span><br><span class="xml">      const currentPercent = parseFloat(this.currentTime / totalTime).toFixed(</span><br><span class="xml">        2</span><br><span class="xml">      );</span><br><span class="xml">      const circleLength = Math.floor(2 * Math.PI * 50);</span><br><span class="xml">      return currentPercent * circleLength;</span><br><span class="xml">    &#125;,</span><br><span class="xml">  &#125;,</span><br><span class="xml">  created() &#123;</span><br><span class="xml">    this.currentTime = this.initialValue;</span><br><span class="xml">    if (this.autoPlay) &#123;</span><br><span class="xml">      this.start();</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  methods: &#123;</span><br><span class="xml">    start() &#123;</span><br><span class="xml">      clearInterval(this.timer);</span><br><span class="xml">      this.timer = setInterval(() =&gt; &#123;</span><br><span class="xml">        if (this.currentTime &lt;= 0) &#123;</span><br><span class="xml">          clearInterval(this.timer);</span><br><span class="xml">          // 派发事件-倒计时结束</span><br><span class="xml">          this.$emit(&quot;turnOver&quot;);</span><br><span class="xml">          return;</span><br><span class="xml">        &#125;</span><br><span class="xml">        this.currentTime -= 1;</span><br><span class="xml">      &#125;, 1000);</span><br><span class="xml">    &#125;,</span><br><span class="xml">    stop() &#123;</span><br><span class="xml">      clearInterval(this.timer);</span><br><span class="xml">    &#125;,</span><br><span class="xml">    reset() &#123;</span><br><span class="xml">      this.stop();</span><br><span class="xml">      this.currentTime = this.initialValue;</span><br><span class="xml">    &#125;,</span><br><span class="xml">  &#125;,</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="复合式API的实现"><a href="#复合式API的实现" class="headerlink" title="复合式API的实现"></a>复合式API的实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-keyword">import</span> &#123; ref, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  props: &#123;<br>    initialValue: &#123;<br>      type: <span class="hljs-built_in">Number</span>,<br>      <span class="hljs-keyword">default</span>: <span class="hljs-number">10</span>,<br>    &#125;,<br>    autoPlay: &#123;<br>      type: <span class="hljs-built_in">Boolean</span>,<br>      <span class="hljs-keyword">default</span>: <span class="hljs-literal">true</span>,<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props,context</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> currentTime = ref(props.initialValue)<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span> <span class="hljs-comment">// 定时器</span><br><br>    <span class="hljs-keyword">const</span> start = <span class="hljs-function">()=&gt;</span> &#123;<br>      <span class="hljs-built_in">clearInterval</span>(timer);<br>      timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (currentTime.value &lt;= <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-built_in">clearInterval</span>(timer);<br>          <span class="hljs-comment">// 派发事件</span><br>          context.emit(<span class="hljs-string">&quot;turnOver&quot;</span>);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        currentTime.value -= <span class="hljs-number">1</span>;<br>      &#125;, <span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> stop = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">clearInterval</span>(timer);<br>    &#125;<br>    <span class="hljs-keyword">const</span> reset = <span class="hljs-function">()=&gt;</span> &#123;<br>      stop()<br>      currentTime.value = props.initialValue;<br>    &#125;<br>    <span class="hljs-comment">// 环形进度条</span><br>    <span class="hljs-keyword">const</span> process = computed(<span class="hljs-function">()=&gt;</span>&#123;<br>      <span class="hljs-keyword">const</span> totalTime = props.initialValue;<br>      <span class="hljs-keyword">const</span> currentPercent = <span class="hljs-built_in">parseFloat</span>(currentTime.value / totalTime).toFixed(<br>        <span class="hljs-number">2</span><br>      );<br>      <span class="hljs-keyword">const</span> circleLength = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">50</span>);<br>      <span class="hljs-keyword">return</span> currentPercent * circleLength;<br>    &#125;)<br><br>    <span class="hljs-keyword">if</span> (props.autoPlay) &#123;<br>      start();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      currentTime,<br>      process,<br>      start,<br>      stop,<br>      reset<br>    &#125;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="script-setup版实现"><a href="#script-setup版实现" class="headerlink" title="script setup版实现"></a>script setup版实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-comment">// 这里定义的所有变量都可以直接在模板使用，包括improt导入的组件或方法官方：顶层的绑定会被暴露给模板）。但是,</span><br><span class="hljs-comment">// 当需要通过模板 ref 或者 $parent访问该组件实例时，需要使用defineExpose明确要暴露出去的属性</span><br><span class="hljs-keyword">import</span> &#123; ref, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">// 使用defineProps声明props</span><br><span class="hljs-keyword">const</span> props = defineProps(&#123;<br>  initialValue: &#123;<br>    type: <span class="hljs-built_in">Number</span>,<br>    <span class="hljs-keyword">default</span>: <span class="hljs-number">10</span>,<br>  &#125;,<br>  autoPlay: &#123;<br>    type: <span class="hljs-built_in">Boolean</span>,<br>    <span class="hljs-keyword">default</span>: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;);<br><br><span class="hljs-comment">// 使用defineEmits声明emits</span><br><span class="hljs-keyword">const</span> emit = defineEmits([<span class="hljs-string">&quot;turnOver&quot;</span>]);<br><br><span class="hljs-keyword">let</span> currentTime = ref(props.initialValue);<br><span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 定时器</span><br><br><span class="hljs-keyword">const</span> start = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">clearInterval</span>(timer);<br>  timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (currentTime.value &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">clearInterval</span>(timer);<br>      emit(<span class="hljs-string">&quot;turnOver&quot;</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    currentTime.value -= <span class="hljs-number">1</span>;<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;;<br><span class="hljs-keyword">const</span> stop = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">clearInterval</span>(timer);<br>&#125;;<br><span class="hljs-keyword">const</span> reset = <span class="hljs-function">() =&gt;</span> &#123;<br>  stop()<br>  currentTime.value = props.initialValue;<br>&#125;;<br><span class="hljs-comment">// 环形进度条</span><br><span class="hljs-keyword">const</span> process = computed(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> totalTime = props.initialValue;<br>  <span class="hljs-keyword">const</span> currentPercent = <span class="hljs-built_in">parseFloat</span>(currentTime.value / totalTime).toFixed(<span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">const</span> circleLength = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">50</span>);<br>  <span class="hljs-keyword">return</span> currentPercent * circleLength;<br>&#125;);<br><br><span class="hljs-keyword">if</span> (props.autoPlay) &#123;<br>  start();<br>&#125;<br><br><span class="hljs-comment">// 使用defineExpose明确要暴露出去的属性</span><br>defineExpose(&#123;<br>  start,<br>  stop,<br>  reset,<br>&#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>复合式API是Vue3新增的、相较于“选项式API”而言的，一种新的组件编写形式。用以解决选项式API，在大型复杂组件中存在的逻辑关注点分散问题。它可以帮助我们更好的进行代码聚合和复用。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>手摸手教学之白嫖博客并自动部署</title>
    <link href="/2021/11/14/%E7%99%BD%E5%AB%96%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/11/14/%E7%99%BD%E5%AB%96%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="手摸手教学之白嫖博客并自动部署-Hexo-GitHub-Pages-GitHub-Actions"><a href="#手摸手教学之白嫖博客并自动部署-Hexo-GitHub-Pages-GitHub-Actions" class="headerlink" title="手摸手教学之白嫖博客并自动部署(Hexo+GitHub Pages+GitHub Actions)"></a>手摸手教学之白嫖博客并自动部署(Hexo+GitHub Pages+GitHub Actions)</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>先赞后看，已成习惯，大家好，我是奉旨撸码的胖大海。</p><p>年轻的时候弄了个博客，每年都只会被访问一次……在阿里云给我下续费通牒的时候。</p><p>很冤，但抱着”每个前端人都应该有自己的博客“的信念，咬着牙续费了几次。</p><p>今年3月份，续费通知如约而至，我再一次来到了历史的岔路口。</p><p>此刻，6*12块钱和心中的信仰，站在命运天平的两端，左右摇曳……</p><p>如你所见，事情的结局是：TMD我全都要，小孩子才做选择题！</p><p>独乐乐不如众乐乐，一篇”手摸手教学之白嫖博客并持续集成“献给各位。</p><h3 id="效果前瞻"><a href="#效果前瞻" class="headerlink" title="效果前瞻"></a>效果前瞻</h3><p><img src="https://www.zhaohaipeng.com/img/20211115/blog-index.jpg" alt="blog-index"></p><p><a href="https://www.zhaohaipeng.com/">前往围观</a></p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ul><li>Hexo<br>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</li><li>GitHub Pages<br>GitHub Pages是 GitHub的网站托管服务。通过简单的配置就可以把你的仓库变成一个静态资源服务器， 直接从您的GitHub存储库托管</li><li>GitHub Actions<br><a href="https://github.com/features/actions">GitHub Actions</a> 是 GitHub 的<a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">持续集成服务</a>。持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub Actions允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。<br>感兴趣的小伙伴，移步<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">阮一峰大佬的GitHub Actions 入门教程</a>。</li></ul><h3 id="Hexo项目搭建"><a href="#Hexo项目搭建" class="headerlink" title="Hexo项目搭建"></a>Hexo项目搭建</h3><p>白嫖第一步：创建项目并实现本地预览。</p><h4 id="1-全局安装hexo-cli"><a href="#1-全局安装hexo-cli" class="headerlink" title="1. 全局安装hexo-cli"></a>1. 全局安装hexo-cli</h4>   <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><h4 id="2-初始化项目"><a href="#2-初始化项目" class="headerlink" title="2. 初始化项目"></a>2. 初始化项目</h4>   <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">hexo <span class="hljs-function"><span class="hljs-keyword">init</span> &lt;folder&gt;</span><br></code></pre></td></tr></table></figure><p>   目录结构应该是这样式的<br>   <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">├── _<span class="hljs-built_in">config</span>.landscape.yml<br>├── _<span class="hljs-built_in">config</span>.yml<br>├── db.<span class="hljs-keyword">json</span><br><span class="hljs-keyword">├── </span>node_modules<br>├── package-lock.<span class="hljs-keyword">json</span><br><span class="hljs-keyword">├── </span>package.<span class="hljs-keyword">json</span><br><span class="hljs-keyword">├── </span><span class="hljs-keyword">scaffolds</span><br><span class="hljs-keyword">├── </span>source<br>└── themes<br></code></pre></td></tr></table></figure></p><h4 id="3-安装依赖"><a href="#3-安装依赖" class="headerlink" title="3. 安装依赖"></a>3. 安装依赖</h4>   <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> <span class="hljs-symbol">&lt;folder&gt;</span><br>npm i<br></code></pre></td></tr></table></figure><h4 id="4-运行"><a href="#4-运行" class="headerlink" title="4. 运行"></a>4. 运行</h4>   <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-builtin-name">run</span> server<br></code></pre></td></tr></table></figure><p> 浏览器访问<a href="http://localhost:4000/">http://localhost:4000/</a><br>   <img src="https://www.zhaohaipeng.com/img/20211115/image-20210419192733280.png" alt="image-20210419192733280"></p><h4 id="5-应用主题"><a href="#5-应用主题" class="headerlink" title="5. 应用主题"></a>5. 应用主题</h4><p>   有点丑，咱们给换个主题。在知乎看了好多答案，选来选取，还是(<a href="https://zkqiang.cn/">张凯强的技术分享</a>)最有眼缘。</p><p>   5.1. 安装主题<a href="https://link.zhihu.com/?target=https://github.com/fluid-dev/hexo-theme-fluid">hexo-theme-fluid</a></p><pre><code>npm install --save hexo-theme-fluid</code></pre><p>   5.2. 修改配置</p><pre><code>// _config.ymllanguage: zh-CNtheme: fluid</code></pre><p>   5.3. 重启服务并刷新页面</p><p><img src="https://www.zhaohaipeng.com/img/20211115/image-20210419194158578.png" alt="image-20210419194158578"><br>   舒服了……当然你也可以自己选。hexo官网<a href="https://hexo.io/themes/">348款主题</a>总有一款适合你。</p><h4 id="6-构建"><a href="#6-构建" class="headerlink" title="6. 构建"></a>6. 构建</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-builtin-name">run</span> build<br></code></pre></td></tr></table></figure><p>  执行成功后，项目中会多出一个public目录，如果不托管到Git Pages的话，把它上传到你的静态资源服务器即可。</p><h3 id="GitHub-Actions自动部署"><a href="#GitHub-Actions自动部署" class="headerlink" title="GitHub Actions自动部署"></a>GitHub Actions自动部署</h3><p>白嫖第二步：提交代码到GithHub并实现自动部署</p><h4 id="1-在Github新建仓库并提交代码"><a href="#1-在Github新建仓库并提交代码" class="headerlink" title="1. 在Github新建仓库并提交代码"></a>1. 在Github新建仓库并提交代码</h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br>git add .<br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>git branch -M main<br>git remote add origin git@github.com:qq9694526/blog.git<br>git push -u origin main<br></code></pre></td></tr></table></figure><h4 id="2-生成秘钥"><a href="#2-生成秘钥" class="headerlink" title="2. 生成秘钥"></a>2. 生成秘钥</h4><p>   参照<a href="https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token">官方文档</a>生成秘钥， <strong>Select scopes</strong>仅选择workflow那一项即可。<br>   ps: 创建成功记得复制秘钥</p><h4 id="3-设置秘钥"><a href="#3-设置秘钥" class="headerlink" title="3. 设置秘钥"></a>3. 设置秘钥</h4><p><img src="https://www.zhaohaipeng.com/img/20211115/image-20210420094437071.png" alt="image-20210420094437071"><br>   把上一步复制的秘钥粘贴进去，并起个名字，后面脚本会用到。我这里用的ACCESS_TOKEN</p><h4 id="4-新建actions脚本"><a href="#4-新建actions脚本" class="headerlink" title="4. 新建actions脚本"></a>4. 新建actions脚本</h4><p>   在根目录下依次创建.github/workflows/deploy.yml，内容如下</p>   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">and</span> <span class="hljs-string">Deploy</span><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build-and-deploy:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@master</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">submodules:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">and</span> <span class="hljs-string">Deploy</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">solybum/hexo-deploy@master</span><br>      <span class="hljs-attr">env:</span><br>        <span class="hljs-attr">PERSONAL_TOKEN:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.ACCESS_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">PUBLISH_REPOSITORY:</span> <span class="hljs-string">qq9694526/blog</span> <span class="hljs-comment"># The repository the action should deploy to.</span><br>        <span class="hljs-attr">BRANCH:</span> <span class="hljs-string">blog</span>  <span class="hljs-comment"># The branch the action should deploy to.</span><br>        <span class="hljs-attr">PUBLISH_DIR:</span> <span class="hljs-string">./public</span> <span class="hljs-comment"># The folder the action should deploy.</span><br><br></code></pre></td></tr></table></figure><p>它的作用就是当main分支有代码提交时，自动构建并发布到blog分支。</p><p>这里需要修改PERSONAL_TOKEN、PUBLISH_REPOSITORY和BRANCH为自己的    </p><p>Ps: 这是我在<a href="https://github.com/marketplace?type=actions&query=hexo">Actions库</a>里搜hexo抄来的，大家也可以自行选择。</p><h4 id="5-效果展示"><a href="#5-效果展示" class="headerlink" title="5. 效果展示"></a>5. 效果展示</h4><p>现在提交任意代码后，脚本会被触发，且在Actions能看到脚本执行情况。</p><p>   <img src="https://www.zhaohaipeng.com/img/20211115/image-20210420100156617.png" alt="image-20210420100156617"><br>   等待执行完毕，切换到blog分支(上面.yml倒数第二行有配置)，可以看到构建后的代码被提交到了这里。</p><p>   <img src="https://www.zhaohaipeng.com/img/20211115/image-20210420100330332.png" alt="image-20210420100330332"></p><p>   以后咱们每次在main push代码，GitHub Actions都会自动的帮我们构建并发布到远程分支</p><h3 id="GitHub-Pages托管网站"><a href="#GitHub-Pages托管网站" class="headerlink" title="GitHub Pages托管网站"></a>GitHub Pages托管网站</h3><p>白嫖第三步：网站托管并设置域名，实现通过域名访问博客</p><h4 id="1-设置"><a href="#1-设置" class="headerlink" title="1. 设置"></a>1. 设置</h4><p>这个设置就是把你的仓库变成一个静态资源服务器</p><p><img src="https://www.zhaohaipeng.com/img/20211115/image-20210420100644607.png" alt="image-20210420100644607"></p><h4 id="2-域名解析"><a href="#2-域名解析" class="headerlink" title="2. 域名解析"></a>2. 域名解析</h4><p>   没有域名的请直接第四步<br>   这是我在阿里云域名的解析配置</p><p><img src="https://www.zhaohaipeng.com/img/20211115/image-20211115094130823.png" alt="image-20211115094130823"></p><h4 id="3-设置自定义域名"><a href="#3-设置自定义域名" class="headerlink" title="3. 设置自定义域名"></a>3. 设置自定义域名</h4><p><img src="https://www.zhaohaipeng.com/img/20211115/image-20211115094839294.png" alt="image-20211115094839294"></p><p>   保存后，就可以通过<a href="https://www.zhaohaipeng.com/%E8%AE%BF%E9%97%AE%E4%BA%86">https://www.zhaohaipeng.com/访问了</a></p><h4 id="4-不自定义域名"><a href="#4-不自定义域名" class="headerlink" title="4. 不自定义域名"></a>4. 不自定义域名</h4><p>   如果不自定义域名，咱们可以直接通过<a href="https://qq9694526.github.io/blog/%E8%AE%BF%E9%97%AE%EF%BC%8C%E4%BD%86%E6%89%93%E5%BC%80%E5%90%8E%E4%BC%9A%E6%9C%89%E5%BE%88%E5%A4%9A404%E3%80%82">https://qq9694526.github.io/blog/访问，但打开后会有很多404。</a><br>   <a href="https://hexo.io/zh-cn/docs/configuration">Hexo官网</a>中有相关说明</p><blockquote><p>如果您的网站存放在子目录中，例如 <code>http://example.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://example.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。咱们需要修改构建配置，在_config.yml中新增根路径配置</p></blockquote>   <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> _config.yml<br>root: <span class="hljs-string">&#x27;/blog/&#x27;</span><br></code></pre></td></tr></table></figure><p>可以本地npm run  build验证下结果。看到public/index.html中（拉到最下面）js路径有以下变化，说明配置已生效。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/boot.js&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/blog/js/boot.js&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 现在提交代码、触发Actions成功后，<a href="https://qq9694526.github.io/blog/%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%E4%BA%86">https://qq9694526.github.io/blog/就可以正常访问了</a></p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-自动化部署后自定义域名丢失"><a href="#1-自动化部署后自定义域名丢失" class="headerlink" title="1. 自动化部署后自定义域名丢失"></a>1. 自动化部署后自定义域名丢失</h4><p>​    在source新增CNAME文件</p><h4 id="2-文档描述不具体、不理解配置项的作用？"><a href="#2-文档描述不具体、不理解配置项的作用？" class="headerlink" title="2. 文档描述不具体、不理解配置项的作用？"></a>2. 文档描述不具体、不理解配置项的作用？</h4><p>​    可以通过查看主题源码中的.ejs文件，分析配置的作用和获取文档中未说明的配置项</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li>Hexo主题<a href="https://link.zhihu.com/?target=https://github.com/fluid-dev/hexo-theme-fluid">hexo-theme-fluid</a></li><li><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">GitHub Actions 入门教程</a></li><li>图片资源<a href="https://pixabay.com/zh/">pixabay</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>入门即巅峰，一文读懂Vue3.0的改进与优化</title>
    <link href="/2021/03/16/%E5%85%A5%E9%97%A8%E5%8D%B3%E5%B7%85%E5%B3%B0%EF%BC%8C%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82Vue3.0%E7%9A%84%E6%94%B9%E8%BF%9B%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <url>/2021/03/16/%E5%85%A5%E9%97%A8%E5%8D%B3%E5%B7%85%E5%B3%B0%EF%BC%8C%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82Vue3.0%E7%9A%84%E6%94%B9%E8%BF%9B%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文旨在通俗易懂的回答：相较于2x，Vue3.0都做了哪些改进与优化。</p><p>分为三个层面：性能、源码和新特性。</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="1-引入tree-shaking技术，减少打包体积"><a href="#1-引入tree-shaking技术，减少打包体积" class="headerlink" title="1.引入tree-shaking技术，减少打包体积"></a>1.引入tree-shaking技术，减少打包体积</h4><p>众所周知，ES6的Module，当我们引入某个模块，模块是整个加载的，构建时也会被全部打包。即便我们只用了其中1个方法。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./xxx.js&#x27;</span> <br></code></pre></td></tr></table></figure><p>我只想收获一缕春风，你却给了我整个春天。</p><p>tree-shaking会在编译阶段标记未被引用的函数或对象，在压缩阶段去删除那些标记过的无用代码，从而实现按需打包。</p><h4 id="2-数据劫持方案优化，由Object-defineProperty改为Proxy对象"><a href="#2-数据劫持方案优化，由Object-defineProperty改为Proxy对象" class="headerlink" title="2.数据劫持方案优化，由Object.defineProperty改为Proxy对象"></a>2.数据劫持方案优化，由Object.defineProperty改为Proxy对象</h4><p>众所周知，Object.defineProperty有局限性。它侦听的是对象上某个属性的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(data, <span class="hljs-string">&#x27;a&#x27;</span>,&#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// track</span><br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// trigger</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>注意！它侦听的是某个<strong>属性</strong>。如果要侦听对象，是需要通过循环遍历劫持所有属性来实现的。这必然会带来性能负担，且不能侦听对象属性的新增和删除。这就是官方所说的<a href="%5Bhttps://cn.vuejs.org/v2/guide/reactivity.html#%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E5%8F%98%E5%8C%96">”由于 JavaScript 的限制，Vue <strong>不能检测</strong>数组和对象的变化。“</a>。大家有没有感受到一股怨念……哈哈😁</p><p>造成的直接结果就是，响应式在以下场景是失效的。</p><ul><li>当添加或移除对象属性时</li><li>当利用索引直接设置一个数组项时</li><li>当修改数组的长度时</li></ul><p>为此，Vue不得不扩展Array对象并提供额外的$set和$delete来解决这个问题，简单的背后可“不简单”。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>的出现则像一束光照在了响应式的脑门上，使得Vue有机会弥补”JavaScript 限制“的遗憾。</p><p>因为，它劫持的是整个对象。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">const</span> <span class="hljs-keyword">target</span> = &#123;<br>  message1: <span class="hljs-string">&quot;hello&quot;</span>,<br>  message2: <span class="hljs-string">&quot;everyone&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">handler</span> = &#123;<br>  get: function(<span class="hljs-keyword">target</span>, prop, receiver) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;world&quot;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> Proxy(<span class="hljs-keyword">target</span>, <span class="hljs-keyword">handler</span>);<br></code></pre></td></tr></table></figure><p>响应式的天命将星有没有？这里给尤大来点背景音乐——爱不释手的……红色高跟鞋^^破音……</p><h4 id="3-编译优化"><a href="#3-编译优化" class="headerlink" title="3.编译优化"></a>3.编译优化</h4><p>众所周知，Vue2.0中数据更新触发重新渲染的粒度是组件级的。这相较于React会重新渲染整个组件子树来说（不使用<code>PureComponent</code> 和 <code>shouldComponentUpdate</code>的情况下 ），有着明显的性能提升。但尤大觉得这还不够，他还能更秀。</p><p>Vue3.0 在编译阶段设计了 Block 的概念。它会根据是否有响应式插值，把节点区分为动态和静态，然后在patch阶段 只比对并更新 Block 中的动态子节点。从而避免了不必要的静态节点的比对，实现了运行时组件更新的性能优化。</p><p>除此之外，编译过程中还增加了AST（抽象语法树）。流程大致为：解析template模板生成AST节点对象，遍历AST并进行词法分析，通过各种转换函数完善虚拟节点的语义和信息，最终生成用于渲染 vnode的render函数。</p><p>编译应该是Vue源码中最复杂的一块了，尢大也说过，懂编译原理就可以为所欲为，感兴趣的小朋友，墙裂推荐去看看黄轶老师的《Vue.js 3.0 核心源码解析》。突出一个字：硬核。</p><h3 id="源码层面"><a href="#源码层面" class="headerlink" title="源码层面"></a>源码层面</h3><h4 id="1-更好的源码组织方式"><a href="#1-更好的源码组织方式" class="headerlink" title="1.更好的源码组织方式"></a>1.更好的源码组织方式</h4><p>Vue3.0采用了 monorepo 的方式管理项目代码。我们先通过目录结构直观的感受一下……</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>.x<br>├── src<br>│   ├── compiler <span class="hljs-regexp">//</span>模板编译相关<br>│   ├── core <span class="hljs-regexp">//</span>与平台无关的通用运行时代码<br>│   ├── platforms <span class="hljs-regexp">//</span>平台专有代码<br>│   ├── server <span class="hljs-regexp">//</span>服务端渲染<br>│   ├── sfc <span class="hljs-regexp">//</span>.vue单文件解析<br>│   └── shared <span class="hljs-regexp">//</span>共享工具代码<br></code></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vim">// <span class="hljs-number">3</span>.<span class="hljs-keyword">x</span><br>├── packages<br>│   ├── <span class="hljs-keyword">compiler</span>-core<br>│   ├── <span class="hljs-keyword">compiler</span>-dom<br>│   ├── <span class="hljs-keyword">compiler</span>-sfc<br>│   ├── <span class="hljs-keyword">compiler</span>-ssr<br>│   ├── <span class="hljs-keyword">global</span>.d.<span class="hljs-keyword">ts</span><br>│   ├── reactivity<br>│   ├── <span class="hljs-keyword">runtime</span>-core<br>│   ├── <span class="hljs-keyword">runtime</span>-dom<br>│   ├── <span class="hljs-keyword">runtime</span>-test<br>│   ├── server-renderer<br>│   ├── shared<br>│   ├── size-check<br>│   ├── template-explorer<br>│   └── vue<br></code></pre></td></tr></table></figure><p>更细粒度、更明晰的模块划分有没有？其实，monorepo最主要的好处是统一的工作流和代码共享。Vue3.0源码中的一些 package是可以独立运行的，比如 reactivity 响应式库。</p><h4 id="2-使用TypeScript开发"><a href="#2-使用TypeScript开发" class="headerlink" title="2.使用TypeScript开发"></a>2.使用TypeScript开发</h4><p>没啥好说的，应该是三赢。Vue趁着TypeScript的大势所趋，顺势而上；TypeScript平添一员猛将，帝国版图一日千里；咱们平民老百姓，则省去了维护.ts的烦恼。真的好想一键三连啊……[狗头👏]</p><p>本人TypeScript用的少，说不出什么深刻的理解。只能草草的祝TypeScript长命百岁，然后默默记住它的好：</p><ul><li>显式类型使我们的代码可读性更高、更加的健壮可靠；</li><li>静态类型检测可以帮助我们避免很多由于类型导致的错误；</li><li>有利于 IDE 对变量类型的推导，从而提供精准有效的代码提示。</li></ul><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><h4 id="1-复合式API"><a href="#1-复合式API" class="headerlink" title="1.复合式API"></a>1.复合式API</h4><p>如果追根溯源的话，还得从”Hello Vue!”说起。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">var app = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-keyword">e</span><span class="hljs-variable">l:</span> <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  dat<span class="hljs-variable">a:</span> &#123;<br>    message: <span class="hljs-string">&#x27;Hello Vue!&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Hello Vue!<br></code></pre></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/guide/index.html#%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%B8%B2%E6%9F%93">我们已经成功创建了第一个 Vue 应用！所有东西都是<strong>响应式的</strong>！</a>”</p><p>时至今日，仿佛还是能感受到那种力透纸背的骄傲与欣喜。不经历JQ的时代，怕是很难体会到这点。但这并不妨碍，我们对它有着近乎一致的第一印象：简单、直观。</p><p>通过配置的方式开发页面，显然更符合人类的直觉 ，这为Vue赢得了“容易上手”的好名声。也是它后来能迅速声名鹤起，继而席卷整个前端世界的重要原因之一。</p><p>但……<strong>命运中的一切馈赠早已在暗中标好了价格</strong>，这是有代价的。</p><p>当组件包含功能较多，变得越来越复杂的时候，Options API的方式会导致逻辑关注点分散，继而使得理解和维护组件变得困难。官方文档中的这个大型组件的示例，很好的展示了这点。其中逻辑关注点按颜色进行了分组。</p><p><img src="/img/vue3-api.png" alt="Vue 选项式 API: 按选项类型分组的代码"></p><p>为了解决这个问题，使我们能够将同一逻辑关注点相关的代码配置在一起，并实现逻辑复用，组合式 API应运而生。</p><p>直接上答案，下面是通过组合式 API重构后的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// src/components/UserRepositories.vue</span><br><span class="hljs-keyword">import</span> &#123; toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> useUserRepositories <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/composables/useUserRepositories&#x27;</span><br><span class="hljs-keyword">import</span> useRepositoryNameSearch <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/composables/useRepositoryNameSearch&#x27;</span><br><span class="hljs-keyword">import</span> useRepositoryFilters <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/composables/useRepositoryFilters&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  components: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,<br>  props: &#123;<br>    user: &#123; <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span> &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; user &#125; = toRefs(props)<br><br>    <span class="hljs-keyword">const</span> &#123; repositories, getUserRepositories &#125; = useUserRepositories(user)<br><br>    <span class="hljs-keyword">const</span> &#123;<br>      searchQuery,<br>      repositoriesMatchingSearchQuery<br>    &#125; = useRepositoryNameSearch(repositories)<br><br>    <span class="hljs-keyword">const</span> &#123;<br>      filters,<br>      updateFilters,<br>      filteredRepositories<br>    &#125; = useRepositoryFilters(repositoriesMatchingSearchQuery)<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-comment">// 因为我们并不关心未经过滤的仓库</span><br>      <span class="hljs-comment">// 我们可以在 `repositories` 名称下暴露过滤后的结果</span><br>      repositories: filteredRepositories,<br>      getUserRepositories,<br>      searchQuery,<br>      filters,<br>      updateFilters<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先忽略setup、toRefs这些有些陌生的语法，仅从结构上去看。可以明显看到，它按“逻辑相关”的原则，将部分组件逻辑抽象成可重用块，拆分出了三个composables，然后把其间的功能点在父组件中进行了统一的安装执行。代码结构、运行逻辑清晰明了，逻辑关注点分散的问题一去不复返。</p><p>同时，它还完成了组件级以下的逻辑复用。在此之前，当逻辑分散在data、computed、methods、filters…… 我们想要复用，一般是通过mixins来实现的。mixins的缺点很明显，首先我们不能向 mixin 传递任何参数来改变它的逻辑，这降低了它在抽象逻辑方面的灵活性。另外，当组件中存在多个mixins，就存在变量覆盖、数据来源不明的问题。</p><p>本节有些长，我们做个总结：<strong>复合式API是一种通过逻辑关注点组织代码的新方法，它可以帮助我们更好的进行代码逻辑的聚合和复用。</strong></p><h4 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h4><p>Teleport是3.0新增的内置组件，它允许我们指定组件元素挂载到哪个DOM节点下。以应对那些 组件中部分元素需要放置在组件外节点甚至Vue app 之外的场景。</p><p>下面是一个全屏模态窗的例子</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// vue</span><br>app.component(<span class="hljs-string">&#x27;modal-button&#x27;</span>, &#123;<br>  template: `<br>    &lt;button @click=<span class="hljs-string">&quot;modalOpen = true&quot;</span>&gt;<br>        Open full screen modal! (With teleport!)<br>    &lt;/button&gt;<br>    &lt;teleport to=<span class="hljs-string">&quot;body&quot;</span>&gt;<br>      &lt;div v-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;modalOpen&quot;</span> <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">modal</span>&quot;&gt;<br>        &lt;<span class="hljs-symbol">div</span>&gt;<br>          <span class="hljs-symbol">I</span>&#x27;<span class="hljs-symbol">m</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">teleported</span> <span class="hljs-symbol">modal</span>! <br>          (<span class="hljs-symbol">My</span> <span class="hljs-symbol">parent</span> <span class="hljs-symbol">is</span> &quot;<span class="hljs-symbol">body</span>&quot;)<br>          &lt;<span class="hljs-symbol">button</span> @<span class="hljs-symbol">click</span>=&quot;<span class="hljs-symbol">modalOpen</span> = <span class="hljs-symbol">false</span>&quot;&gt;<br>            <span class="hljs-symbol">Close</span><br>          &lt;/<span class="hljs-symbol">button</span>&gt;<br>        &lt;/<span class="hljs-symbol">div</span>&gt;<br>      &lt;/<span class="hljs-symbol">div</span>&gt;<br>    &lt;/<span class="hljs-symbol">teleport</span>&gt;<br>  `,<br>  <span class="hljs-symbol">data</span>() &#123;<br>    <span class="hljs-keyword">return</span> &#123; <br>      modalOpen: <span class="hljs-literal">false</span><br>    &#125;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// css</span><br>.modal &#123;<br>  position: absolute;<br>  top: <span class="hljs-number">0</span>; right: <span class="hljs-number">0</span>; bottom: <span class="hljs-number">0</span>; left: <span class="hljs-number">0</span>;<br>  background-color: rgba(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">.5</span>);<br>  display: flex;<br>  flex-direction: column;<br>  align-items: center;<br>  justify-content: center;<br>&#125;<br><br>.modal div &#123;<br>  display: flex;<br>  flex-direction: column;<br>  align-items: center;<br>  justify-content: center;<br>  background-color: white;<br>  width: <span class="hljs-number">300</span>px;<br>  height: <span class="hljs-number">300</span>px;<br>  padding: <span class="hljs-number">5</span>px;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的.modal节点会被挂载到props to所指定的body中去。</p><p>语法简单、功能直接，能说的并不多。只是这组件名 起得可太秀了，Teleport：心灵传输。</p><h4 id="3-片段"><a href="#3-片段" class="headerlink" title="3.片段"></a>3.片段</h4><p>众所周知，2.0的template必须有且仅有一个根节点。否则程序会报错：</p><blockquote><p>The template root requires exactly one element</p></blockquote><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-variable">&lt;template&gt;</span><br>  <span class="hljs-variable">&lt;div&gt;</span><br>    <span class="hljs-variable">&lt;header&gt;</span>...<span class="hljs-variable">&lt;/header&gt;</span><br>    <span class="hljs-variable">&lt;main&gt;</span>...<span class="hljs-variable">&lt;/main&gt;</span><br>    <span class="hljs-variable">&lt;footer&gt;</span>...<span class="hljs-variable">&lt;/footer&gt;</span><br>  <span class="hljs-variable">&lt;/div&gt;</span><br><span class="hljs-variable">&lt;/template&gt;</span><br></code></pre></td></tr></table></figure><p>3.0做了改进，消除了这个限制。官方把 支持多根节点组件的这个特性，称之为片段。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这时候一定有同学会问，为什么2.0不行 3.0就行了呢？</p><p>还记得咱们前面提到的“Vue2.0中数据更新触发重新渲染的粒度是组件级的”吗？Vue就是通过这个根节点，把diff限定在某个组件内提升了新旧DOM比对效率，从而提升渲染性能的。</p><p>3.0的话这个优点还在，只是引入AST后的编译过程，在解析Template模板的最后，始终会创建 AST 根节点 。这个虚拟根节点能起到相同的作用，这样显式的根节点就不再必要了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上，就是本学渣阅读和思考后给出的答案，充斥着大量主观的个人理解。如有偏颇，欢迎指正。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><p><a href="https://www.vue3js.cn/docs/zh/guide/migration/introduction.html">Vue3中文文档</a></p></li><li><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html">深入响应式原理</a></p></li><li><p><a href="https://t10.lagounews.com/aRF6RyRScd850">黄轶老师的《Vue.js 3.0 核心源码解析》</a></p></li><li><p><a href="https://segmentfault.com/a/1190000019309820">Monorepo——大型前端项目的代码管理方式</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript设计模式实践之组合模式</title>
    <link href="/2021/01/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/01/10/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>组合模式就是将对象组合成树形结构，且这些对象对外提供一致调用方法的设计。它除了能很好的表现对象之间”部分-整体‘的层次结构外，还能方便我们进行统一调用和遍历的操作。<br><img src="/img/zuhe.png" alt="组合模式"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>如果硬要举一个例子的话，那么……DOM就是组合模式的典范。</p><p>它以树形结构组织节点，每个节点又有一致的访问（属性和方法）。</p><p>对前端而言，应该没有比这更生动、形象、逼真、易懂的例子了吧……</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>它比较适合，一系列 有联系的 复杂操作的场景，比如扫描文件夹、打开所有电器、展开所有菜单这种……</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript设计模式实践之命令模式</title>
    <link href="/2021/01/05/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/01/05/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>命令模式就是将过程式的请求调用封装在command对象的execute方法里的做法。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>比如说有个“用户点击按钮，刷新菜单目录”的业务逻辑。过程式的调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> MenuBar = &#123;<br>  refresh: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;刷新菜单目录&#x27;</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> bindClick = <span class="hljs-function">() =&gt;</span> &#123;<br>  button.onclick = <span class="hljs-function">() =&gt;</span> &#123;<br>    MenuBar.refresh()<br>  &#125;<br>&#125;<br>bindClick()<br></code></pre></td></tr></table></figure><p>封装成命令对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 封装命令对象</span><br><span class="hljs-keyword">var</span> RefreshMenuBarCommand = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">receiver</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.receiver = receiver;<br>&#125;;<br>RefreshMenuBarCommand.prototype.execute = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.receiver.refresh();<br>&#125;;<br><span class="hljs-comment">// 安装命令</span><br><span class="hljs-keyword">const</span> bindClick = <span class="hljs-function">(<span class="hljs-params">command</span>) =&gt;</span> &#123;<br>  button.onclick = <span class="hljs-function">() =&gt;</span> &#123;<br>    command.execute();<br>  &#125;<br>&#125;<br>bindClick(<span class="hljs-keyword">new</span> RefreshMenuBarCommand(MenuBar))<br></code></pre></td></tr></table></figure><p>可以看到它通过传递命令对象，实现了请求发送者和接收者的解耦。但也很明显：简单的事情变复杂了。</p><p>其实，在javascript中是不用这么复杂的。因为<strong>命令模式其实是回调函数的一个面向对象的替代品</strong>。</p><p>咱们直接用回调函数的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> bindClick = <span class="hljs-function">(<span class="hljs-params"> callback </span>)=&gt;</span>&#123;<br>  button.onclick = <span class="hljs-function">()=&gt;</span> &#123;<br>    callback();<br>  &#125;<br>&#125;;<br>bindClick(MenuBar.refresh)<br></code></pre></td></tr></table></figure><p>这样也是解耦的。</p><p>其实，由于callback的先入为主，咱们前端很难体会到命令模式的好处，事实上也是如此的。它封装、解耦、易扩展的作用和优点，通过callback + 闭包或发布-订阅模式 也是能获得的。</p><p>总之，命令模式就是<strong>以面向对象之名干回调函数之实</strong>。在JavaScript语言里，咱们可以取其意，但并不一定要用其形。</p><h3 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h3><p>设计模式的主题总是把不变的事物和变化的事物分离开来。   –《JavaScript设计模式与开发实践》</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript设计模式实践之发布-订阅模式</title>
    <link href="/2021/01/02/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/01/02/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近在读《JavaScript设计模式与开发实践》，恰逢手头上的工作任务是项目重构。本系列文章就是对本次学习实战的记录和总结。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>发布-订阅模式又叫观察者模式。它定义对象间的一种一对多关系，当一个对象的状态发生变化时，所有依赖于它的对象都将得到通知。</p><p>举个现实生活里的例子，比如说你非常喜欢一个博客，但不知道它什么时候会更新，所以你就每天甚至每隔几小时去看一下是否有更新。如果用上发布-订阅模式，就相当于你关注了该博客的公众号，它有更新的话，你会立马收到一个推送消息。</p><p>基于此，我们应该很容易联想到dom事件、双向绑定、vuex。确实，在JavaScript语言中，DOM事件、Event对象、Proxy对象等都是发布-订阅模式的典型应用。它们都提供有订阅、发布的能力。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>除了对原生已有实现的使用，书中讲到的“网站登录”和“模块间通信”，都是该模式极佳的应用场景。这些例子很能说明该模式的特点和优势，这里贴一下代码。</p><p>当ajax登录成功，需要更新页面数据，我们通常的做法是这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">login.succ(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>  header.setAvatar( data.avatar); <span class="hljs-comment">// 设置header 模块的头像</span><br>  nav.setAvatar( data.avatar ); <span class="hljs-comment">// 设置导航模块的头像</span><br>  message.refresh(); <span class="hljs-comment">// 刷新消息列表</span><br>  cart.refresh(); <span class="hljs-comment">// 刷新购物车列表</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>很明显，它产生了一个耦合。比如我们现在新增了一个收货地址的模块，也依赖用户信息。不可避免的登录模块就得被迫营业，增加一个调用。当模块较多，且是由不同人编写的时候，登录模块被迫营业的次数会越来越多以至于疲于应付。</p><p>我们完全可以用发布-订阅模式彻底解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js">login.succ(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>  login.trigger(<span class="hljs-string">&#x27;loginSucc&#x27;</span>, data) <span class="hljs-comment">// 发布登录成功的消息</span><br>&#125;)<br><br><span class="hljs-keyword">var</span> header = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// header 模块</span><br>  login.listen(<span class="hljs-string">&#x27;loginSucc&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    header.setAvatar(data.avatar);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> &#123;<br>    setAvatar: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;设置header 模块的头像&#x27;</span>);<br>    &#125;<br>  &#125;<br>&#125;)();<br><br><span class="hljs-keyword">var</span> nav = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// nav 模块</span><br>  login.listen(<span class="hljs-string">&#x27;loginSucc&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    nav.setAvatar(data.avatar);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> &#123;<br>    setAvatar: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">avatar</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;设置nav 模块的头像&#x27;</span>);<br>    &#125;<br>  &#125;<br>&#125;)();<br><br><span class="hljs-keyword">var</span> address = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// nav 模块</span><br>  login.listen(<span class="hljs-string">&#x27;loginSucc&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>    address.refresh(obj);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> &#123;<br>    refresh: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">avatar</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;刷新收货地址列表&#x27;</span>);<br>    &#125;<br>  &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>DOM事件相信大家都已经很熟悉了，这里就练一下Vue3.0响应式原理的基石：ES6的Proxy对象。</p><p>VUE官方在介绍<a href="https://www.vue3js.cn/docs/zh/guide/reactivity.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E6%80%A7">什么是响应性</a>的时候举了一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>  val1: <span class="hljs-number">2</span>,<br>  val2: <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">let</span> sum = obj.val1 + obj.val2<br><span class="hljs-built_in">console</span>.log(sum) <span class="hljs-comment">// 5</span><br><span class="hljs-comment">// 改变值</span><br>obj.val1 = <span class="hljs-number">3</span><br><span class="hljs-comment">// sum是不变的</span><br><span class="hljs-built_in">console</span>.log(sum) <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>当我们更新第一个值，sum并不会被修改。这……天经地义，理所当然，因为JavaScript通常是”非响应的“。</p><p>下面咱们就用Proxy+发布-订阅模式，让它变成响应式的。</p><ol><li>首先基于Proxy，封装一个监听值变化的方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 通过Proxy监听对象变化</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addObjectListener</span>(<span class="hljs-params">data, callback</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(data, &#123;<br>    <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, prop, value</span>)</span> &#123;<br>      data[prop] = value<br>      callback()<br>      <span class="hljs-keyword">return</span> value<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>给obj添加监听</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>  val1: <span class="hljs-number">2</span>,<br>  val2: <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">let</span> sum = obj.val1 + obj.val2<br><span class="hljs-built_in">console</span>.log(sum) <span class="hljs-comment">// 5</span><br><span class="hljs-comment">// 改变值</span><br>obj.val1 = <span class="hljs-number">3</span><br><span class="hljs-comment">// sum结果是不变的</span><br><span class="hljs-built_in">console</span>.log(sum) <span class="hljs-comment">// 5</span><br><span class="hljs-comment">// 添加监听（订阅）</span><br>obj = addObjectListener(obj, <span class="hljs-function">() =&gt;</span> &#123;<br>  sum = obj.val1 + obj.val2<br>&#125;)<br><span class="hljs-comment">// 改变值</span><br>obj.val1 = <span class="hljs-number">3</span><br><span class="hljs-comment">// 可以看到结果变化了</span><br><span class="hljs-built_in">console</span>.log(sum) <span class="hljs-comment">// 6</span><br><br>obj.val2 = <span class="hljs-number">8</span><br><span class="hljs-built_in">console</span>.log(sum) <span class="hljs-comment">//11</span><br><br></code></pre></td></tr></table></figure><p>可以看到在添加监听后，我们再次改变值，sum是有跟着改变的。</p><p>说回设计模式，这中间addObjectListener就是实例化发布者并添加订阅的过程，set函数触发callback则对应了发布/通知的这么一个动作。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript设计模式实践之迭代器模式</title>
    <link href="/2020/12/30/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/12/30/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近在读《JavaScript设计模式与开发实践》，恰逢手头上的工作任务是项目重构。本系列文章就是对本次学习实战的记录和总结。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>迭代器模式是指提供一种方法，顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p><p>现代语言一般都内置的有迭代器实现，我们通常称之为遍历函数。这个在咱们js里是比比皆是，forEach、map、filter、find……数不胜数。详情建议查阅我早前写的另一篇文章<a href="https://juejin.cn/post/6844903736880414734">JS遍历方法总结</a>。</p><p>迭代器分为内部迭代器和外部迭代器。咱们用到的大多数像forEach、$.each都是内部迭代器，外部只需要一次调用。而外部迭代器会显式地请求迭代下一个元素。就像Generator函数那样，需要外部调用next方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 出自《ECMAScript 6 入门》 </span><br><span class="hljs-keyword">const</span> g = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">yield</span> x + y;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-keyword">const</span> gen = g(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>gen.next(); <span class="hljs-comment">// Object &#123;value: 3, done: false&#125;</span><br><br>gen.next(<span class="hljs-number">1</span>); <span class="hljs-comment">// Object &#123;value: 1, done: true&#125;</span><br></code></pre></td></tr></table></figure><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>感觉JavaScript语言对迭代器的实现已经足够强大。很早以前就已经有用map、filter、find、some、every这些高阶函数消灭掉了for循环。</p><h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>浅层次的重构靠整洁代码，深层次的重构靠设计模式。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript设计模式实战之代理模式</title>
    <link href="/2020/12/29/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/12/29/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>代理模式就是给对象提供一个替身对象，以便控制对它的访问的这种机制。根据作用的不同，它分为保护代理、虚拟代理、缓存代理等。</p><p>这玩意在现实生活中很常见，像秘书、经纪人、翰林院，其实都是代理，他们会在正主被访问之前做一些额外且必要的准备工作。在代码世界中的应用更是比比皆是。但凡我们有对函数、组件等进行二次封装，都不可避免的会用到。</p><p>应用场景的话……事实上不方便直接访问某个对象的时候，都是适合编写代理的时候。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>太常见了，略。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript设计模式实战之策略模式</title>
    <link href="/2020/12/28/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/12/28/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>策略模式就是把用于实现同一目标的不同算法、规则封装起来，并使它们可以被相互替换的做法。</p><p>它提供了对开放封闭原则的完美支持，可以有效避免多重条件判断语句。</p><p>像下面这个“根据状态值获取对应文本”的函数，就有策略模式的影子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStatusText</span>(<span class="hljs-params">value</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-string">&quot;Y&quot;</span>:<span class="hljs-string">&quot;已完成&quot;</span>,<br>    <span class="hljs-string">&quot;N&quot;</span>:<span class="hljs-string">&quot;已取消&quot;</span>,<br>    <span class="hljs-string">&quot;C&quot;</span>:<span class="hljs-string">&quot;待确认&quot;</span><br>  &#125;[value]:<span class="hljs-string">&quot;状态未明&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>应用“策略模式”对表单验证的代码进行重构。</p><ol><li>新增一个Validate类</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设计模式之策略模式--表单验证类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Validate</span> </span>&#123;<br>  <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">this</span>.validateFuncs = []<br>  &#125;<br>  add (value, rule, errorMsg) &#123;<br>    <span class="hljs-built_in">this</span>.validateFuncs.push(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 获取对应策略的处理函数</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._strategies[rule](value, errorMsg)<br>    &#125;)<br>  &#125;<br>  check () &#123;<br>    <span class="hljs-keyword">const</span> validateFuncs = <span class="hljs-built_in">this</span>.validateFuncs<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = validateFuncs.length; i &lt; len; i++) &#123;<br>      <span class="hljs-keyword">const</span> errorMsg = (<span class="hljs-function">() =&gt;</span> validateFuncs[i]())()<br>      <span class="hljs-keyword">if</span> (errorMsg) &#123;<br>        <span class="hljs-built_in">this</span>.$toast(errorMsg)<br>        result = <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">break</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>  <span class="hljs-comment">// 策略</span><br>  _strategies = &#123;<br>    isNotEmpty (value, errorMsg) &#123;<br>      <span class="hljs-keyword">const</span> trimedValue = <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;string&#x27;</span> ? value.trim() : value<br>      <span class="hljs-keyword">if</span> (trimedValue === <span class="hljs-string">&#x27;&#x27;</span> || trimedValue === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> errorMsg<br>      &#125;<br>    &#125;,<br>    isNotLessThan (value, errorMsg) &#123;<br>      <span class="hljs-keyword">const</span> [num1, num2] = value<br>      <span class="hljs-keyword">if</span> (num1 &lt; num2) &#123;<br>        <span class="hljs-keyword">return</span> errorMsg<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Validate<br></code></pre></td></tr></table></figure><ol start="2"><li>使用前代码</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">onSubmit</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.payAmount) &#123;<br>    <span class="hljs-built_in">this</span>.$toast(<span class="hljs-string">&quot;请输入购买金额&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.payAmount &gt; <span class="hljs-built_in">this</span>.detail.baseAmt) &#123;<br>    <span class="hljs-built_in">this</span>.$toast(<span class="hljs-string">&quot;购买金额不能小于起存金额&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用后</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">onSubmit</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">const</span> validate = <span class="hljs-keyword">new</span> Validate()<br>  validate.add(<span class="hljs-built_in">this</span>.payAmount, <span class="hljs-string">&#x27;isNotEmpty&#x27;</span>, <span class="hljs-string">&#x27;请输入购买金额&#x27;</span>)<br>  validate.add([<span class="hljs-built_in">this</span>.payAmount, <span class="hljs-built_in">this</span>.detail.baseAmt], <span class="hljs-string">&#x27;isNotLessThan&#x27;</span>, <span class="hljs-string">&#x27;购买金额不能小于起存金额&#x27;</span>)<br>  ...<br>  <span class="hljs-keyword">if</span> (!validate.check()) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的优点是通过取代大段ifelse语句，提升了代码可读性；通过封装变化（校验规则），提升了代码重用性和扩展性。缺点也有，就是我们在使用前需要了解已有策略，这违反了最少知识原则，但可以接受。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次懒癌发作引发的代码重构：动态加载模块</title>
    <link href="/2020/09/01/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%87%92%E7%99%8C%E5%8F%91%E4%BD%9C%E5%BC%95%E5%8F%91%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%EF%BC%9A%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/"/>
    <url>/2020/09/01/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%87%92%E7%99%8C%E5%8F%91%E4%BD%9C%E5%BC%95%E5%8F%91%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%EF%BC%9A%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是一个过程曲折、结局温暖的动人故事。<br>知识点：ES6 import()动态加载模块和webpack的require.context。</p><h3 id="先看下重构前的代码"><a href="#先看下重构前的代码" class="headerlink" title="先看下重构前的代码"></a>先看下重构前的代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// mock/index.js</span><br><span class="hljs-keyword">import</span> getProvinceCity <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/getProvinceCity.js&#x27;</span><br><span class="hljs-keyword">import</span> getAcListInfo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/getAcListInfo.js&#x27;</span><br><span class="hljs-keyword">import</span> sendFreezeApply <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/sendFreezeApply.js&#x27;</span><br><span class="hljs-keyword">import</span> getFreezeList <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/getFreezeList.js&#x27;</span><br><span class="hljs-keyword">import</span> getProjectInfo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/getProjectInfo.js&#x27;</span><br><span class="hljs-keyword">import</span> getProjectList <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/getProjectList.js&#x27;</span><br><span class="hljs-keyword">import</span> getGuaranteeType <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/getGuaranteeType.js&#x27;</span><br><span class="hljs-keyword">import</span> getToken <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/getToken.js&#x27;</span><br><span class="hljs-keyword">import</span> checkProjectUser <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/checkProjectUser.js&#x27;</span><br><span class="hljs-keyword">import</span> checkAiBinding <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/checkAiBinding.js&#x27;</span><br><span class="hljs-keyword">import</span> getAcctType <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/getAcctType.js&#x27;</span><br><span class="hljs-keyword">import</span> getVeriCode <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/getVeriCode.js&#x27;</span><br><span class="hljs-keyword">import</span> getJsApi <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/getJsApi.js&#x27;</span><br><span class="hljs-keyword">import</span> getWeixinUser <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/getWeixinUser.js&#x27;</span><br><span class="hljs-keyword">import</span> getDeductionList <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/getDeductionList.js&#x27;</span><br><span class="hljs-keyword">import</span> getGuaranteeFreezeInfo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/getGuaranteeFreezeInfo.js&#x27;</span><br><span class="hljs-keyword">import</span> checkCard <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/checkCard.js&#x27;</span><br><span class="hljs-keyword">import</span> approvePay <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/approvePay.js&#x27;</span><br><span class="hljs-keyword">import</span> checkPwd <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./data/checkPwd.js&#x27;</span><br><br>Mock.mock(<span class="hljs-regexp">/getProvinceCity$/</span>, getProvinceCity)<br>Mock.mock(<span class="hljs-regexp">/getAcListInfo$/</span>, getAcListInfo)<br>Mock.mock(<span class="hljs-regexp">/sendFreezeApply$/</span>, sendFreezeApply)<br>Mock.mock(<span class="hljs-regexp">/getFreezeList$/</span>, getFreezeList)<br>Mock.mock(<span class="hljs-regexp">/getProjectInfo$/</span>, getProjectInfo)<br>Mock.mock(<span class="hljs-regexp">/getProjectList$/</span>, getProjectList)<br>Mock.mock(<span class="hljs-regexp">/getGuaranteeType$/</span>, getGuaranteeType)<br>Mock.mock(<span class="hljs-regexp">/getToken$/</span>, getToken)<br>Mock.mock(<span class="hljs-regexp">/checkProjectUser$/</span>, checkProjectUser)<br>Mock.mock(<span class="hljs-regexp">/checkAiBinding$/</span>, checkAiBinding)<br>Mock.mock(<span class="hljs-regexp">/getAcctType$/</span>, getAcctType)<br>Mock.mock(<span class="hljs-regexp">/getVeriCode$/</span>, getVeriCode)<br>Mock.mock(<span class="hljs-regexp">/getJsApi$/</span>, getJsApi)<br>Mock.mock(<span class="hljs-regexp">/getWeixinUser$/</span>, getWeixinUser)<br>Mock.mock(<span class="hljs-regexp">/getDeductionList$/</span>, getDeductionList)<br>Mock.mock(<span class="hljs-regexp">/getGuaranteeFreezeInfo$/</span>, getGuaranteeFreezeInfo)<br>Mock.mock(<span class="hljs-regexp">/checkCard$/</span>, checkCard)<br>Mock.mock(<span class="hljs-regexp">/approvePay$/</span>, approvePay)<br>Mock.mock(<span class="hljs-regexp">/checkPwd$/</span>, checkPwd)<br></code></pre></td></tr></table></figure><p>就是对mockjs最基础的应用：引入静态数据、mock匹配请求路径、返回对应数据。<br>没一点毛病！除了太普通显得有点low。<br>low不是错，让我不能忍的是每次新增操作都要CV好几次（最好情况需要复制3次粘贴6次），很累，感觉身体被掏空。<br>重构势在必行！</p><h3 id="for循环走起"><a href="#for循环走起" class="headerlink" title="for循环走起"></a>for循环走起</h3><p>不难看出，import和mock都是重复的，先无脑走个for循环。<br>下面是改造后的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// mock/index.js</span><br><span class="hljs-keyword">const</span> urls = [<br>  <span class="hljs-string">&#x27;getProvinceCity&#x27;</span>,<br>  <span class="hljs-string">&#x27;getAcListInfo&#x27;</span>,<br>  <span class="hljs-string">&#x27;sendFreezeApply&#x27;</span>,<br>  <span class="hljs-string">&#x27;getFreezeList&#x27;</span>,<br>  <span class="hljs-string">&#x27;getProjectInfo&#x27;</span>,<br>  <span class="hljs-string">&#x27;getProjectList&#x27;</span>,<br>  <span class="hljs-string">&#x27;getGuaranteeType&#x27;</span>,<br>  <span class="hljs-string">&#x27;getToken&#x27;</span>,<br>  <span class="hljs-string">&#x27;checkProjectUser&#x27;</span>,<br>  <span class="hljs-string">&#x27;checkAiBinding&#x27;</span>,<br>  <span class="hljs-string">&#x27;getAcctType&#x27;</span>,<br>  <span class="hljs-string">&#x27;getVeriCode&#x27;</span>,<br>  <span class="hljs-string">&#x27;getJsApi&#x27;</span>,<br>  <span class="hljs-string">&#x27;getWeixinUser&#x27;</span>,<br>  <span class="hljs-string">&#x27;getDeductionList&#x27;</span>,<br>  <span class="hljs-string">&#x27;getGuaranteeFreezeInfo&#x27;</span>,<br>  <span class="hljs-string">&#x27;checkCard&#x27;</span>,<br>  <span class="hljs-string">&#x27;approvePay&#x27;</span>,<br>  <span class="hljs-string">&#x27;checkPwd&#x27;</span><br>]<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; urls.length; i++) &#123;<br>  <span class="hljs-keyword">const</span> url = urls[i]<br>  <span class="hljs-keyword">import</span> data <span class="hljs-keyword">from</span> <span class="hljs-string">`./data/<span class="hljs-subst">$&#123;url&#125;</span>.js`</span> <span class="hljs-comment">// eslint 报错</span><br>  Mock.mock(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>$`</span>), data)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样以后再有新增，CV一次就好！！！舒服……<br>可惜，还没试运行，eslint就给报警了：</p><blockquote><p>Parsing error: ‘import’ and ‘export’ may only appear at the top level</p></blockquote><p>于是特意回去翻了<a href="https://es6.ruanyifeng.com/#docs/module">ECMAScript 6 入门 Module那一章</a>，人说的很明白：</p><blockquote><p>由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p></blockquote><blockquote><p>引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）</p></blockquote><p>此路不通，好在后面有解决方案：</p><blockquote><p>ES2020提案 引入import()函数，支持动态加载模块。</p></blockquote><h3 id="使用import函数动态加载模块"><a href="#使用import函数动态加载模块" class="headerlink" title="使用import函数动态加载模块"></a>使用import函数动态加载模块</h3><p>这个简单，动态加载模块走起。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// mock/index.js</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; urls.length; i++) &#123;<br>  <span class="hljs-keyword">const</span> url = urls[i]<br>  <span class="hljs-comment">// 动态加载模块</span><br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">`./data/<span class="hljs-subst">$&#123;url&#125;</span>.js`</span>).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    Mock.mock(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>$`</span>), data.default)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>完美！！！不报错了……<br>欢天喜地的打开页面一看……一直转圈圈。点开network，果然是没拦截住，有两个接口被发送出去了。<br>又点了其他页面，好的？！……除了这两个接口，其他都是能正常被mock的……<br>第一时间怀疑是拼写错误，再三比对确认后，拼写无误！<br>随后在页面又试了几次，发现个规律：只有这两个接口没被mock,且它们都是在created中被调用的。<br>此时‘js执行机制’、‘异步逻辑处理’的知识点纷至沓来，确定是异步问题无疑了。<br>赶紧看下main.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./mock/index.js&#x27;</span> <br><br><span class="hljs-comment">/* eslint-disable no-new */</span><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  router,<br>  store,<br>  template: <span class="hljs-string">&#x27;&lt;App/&gt;&#x27;</span>,<br>  components: &#123; App &#125;<br>&#125;)<br><br><span class="hljs-comment">// mock/index.js</span><br><span class="hljs-comment">// 动态加载模块</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">`./data/<span class="hljs-subst">$&#123;url&#125;</span>.js`</span>).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>  Mock.mock(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>$`</span>), data.default)<br>&#125;)<br></code></pre></td></tr></table></figure><p>不难看出，mock/index.js里面动态加载模块是promise，mock会进异步队列，然后就被排在vue实例化之后执行了。<br>真相大白！vue实例化过程中(created)调用接口时，mock还没执行，也就自然不会拦截请求了……</p><h3 id="解决动态加载模块造成的异步问题"><a href="#解决动态加载模块造成的异步问题" class="headerlink" title="解决动态加载模块造成的异步问题"></a>解决动态加载模块造成的异步问题</h3><p>两个方案：Vue实例化延迟执行、mock/index.js模块Promise化。我选择了前者……</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">const</span> useMock = <span class="hljs-literal">true</span> <span class="hljs-comment">// 是否使用MOCK</span><br><span class="hljs-keyword">if</span> (useMock &amp;&amp; process.env.NODE_ENV === <span class="hljs-string">&#x27;development&#x27;</span>) &#123;<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./mock/index.js&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 由于mock中是动态加载的模块，所以当开启mock时需要延迟实例化</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">/* eslint-disable no-new */</span><br>  <span class="hljs-keyword">new</span> Vue(&#123;<br>    el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    router,<br>    store,<br>    template: <span class="hljs-string">&#x27;&lt;App/&gt;&#x27;</span>,<br>    components: &#123; App &#125;<br>  &#125;)<br>&#125;, useMock ? <span class="hljs-number">100</span> : <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="使用require-context实现免配置"><a href="#使用require-context实现免配置" class="headerlink" title="使用require.context实现免配置"></a>使用require.context实现免配置</h3><p>经评论区<a href="https://juejin.im/user/2576910987834110">蛋蛋大神</a>的指点，使用webpack的<a href="https://webpack.docschina.org/guides/dependency-management/#requirecontext">require.context</a>读取文件列表，达成了免配置效果！<br>以后有新增的话只在data目录下添加js文件就好……<br>最终代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// mock/index.js</span><br><span class="hljs-keyword">import</span> Mock <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mockjs&#x27;</span><br><br><span class="hljs-keyword">const</span> dataFilesContexts = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">&#x27;./data&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-regexp">/\.js$/</span>)<br><span class="hljs-keyword">const</span> urls = dataFilesContexts.keys().map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">//从uri中匹配出文件名</span><br>  <span class="hljs-keyword">const</span> fileNameArr = item.match(<span class="hljs-regexp">/(?&lt;=\/).*(?=.js)/</span>) || []<br>  <span class="hljs-keyword">return</span> fileNameArr[<span class="hljs-number">0</span>]<br>&#125;)<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; urls.length; i++) &#123;<br>  <span class="hljs-keyword">const</span> url = urls[i]<br>  <span class="hljs-comment">// 动态加载模块</span><br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">`./data/<span class="hljs-subst">$&#123;url&#125;</span>.js`</span>).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    Mock.mock(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>$`</span>), data.default)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>把需要“复制3次粘贴6次”的操作降到了零次，这一刻，心中的某种情感被唤醒了。<br>好似一阵风，吹得头上“CV程序员”的帽子晃了一晃。<br>我伸手按住，抬起头，开心的像个孩子…… </p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue单元测试代码大全( jest + vue-test-utils)</title>
    <link href="/2020/08/02/Vue%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8(%20jest%20+%20vue-test-utils)/"/>
    <url>/2020/08/02/Vue%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8(%20jest%20+%20vue-test-utils)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>人(ce)生(shi)如戏，全靠演技(mock)。</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>通过生动详实的例子带你排遍vue单元测试过程中的所有疑惑与难题。</p><p>一定先收藏上，不难预见，当你真正需要并去看的时候，会发自内心的来上一句：不虚此藏。</p><p>技术栈：jest、vue-test-utils。<br>共四个部分：运行时、Mock、Stub、Configuring和CLI。  </p><h3 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h3><p>在跑测试用例时，大家的第一个绊脚石肯定是各种undifned报错。 </p><p>解决这些报错的血泪史还历历在目，现在总结来看，大都是缺少运行时变量抑或异步造成的。<br>这里咱们只说运行时，基本就这两类：</p><h4 id="1-缺少window等环境变量"><a href="#1-缺少window等环境变量" class="headerlink" title="1. 缺少window等环境变量"></a>1. 缺少window等环境变量</h4><p>一般通过引入global-jsdom解决，这也是官方推荐的。当然我们也可以自己在测试代码中直接声明定义。  </p><p>比如我们在业务代码中使用了sessionStorage。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// procudtpay.vue</span><br>&lt;script&gt;<br><span class="hljs-keyword">const</span> sessionParams = <span class="hljs-built_in">window</span>.sessionStorage.getItem(<span class="hljs-string">&#x27;sessionParams&#x27;</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  data () &#123; &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>然后在测试代码中直接重定义，这样在运行时，实际取到的值就是我们在这里定义的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// procudtpay.spec.js</span><br><span class="hljs-built_in">window</span>.sessionStorage = &#123;<br>  getItem: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;type&#x27;</span> &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">import</span> procudtpay <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/procudtpay.vue&#x27;</span><br></code></pre></td></tr></table></figure><p>这里关于<strong>执行顺序</strong>做一点额外说明：  </p><p>示例中sessionParams的赋值是在import引入.vue模块就执行了的，所以对sessionStorage的定义赋值需要在引入之前。  </p><p>如果你的sessionStorage取值是在vue实例化后，比如created中，那么则没有该问题。</p><p>如果你想<strong>重写或者mock一些只读属性</strong>，比如window.loaction、document.getElementById这些。<br>直接赋值是无效的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.getElementById = jest.fn() <span class="hljs-comment">// 不生效</span><br></code></pre></td></tr></table></figure><p>咱们可以使用Object.defineProperty() 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;getElementById&#x27;</span>, &#123;<br>  value: <span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">offsetWidth</span>: <span class="hljs-number">100</span> &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="2-缺少在main-js中定义-注册的全局属性和方法"><a href="#2-缺少在main-js中定义-注册的全局属性和方法" class="headerlink" title="2. 缺少在main.js中定义/注册的全局属性和方法"></a>2. 缺少在main.js中定义/注册的全局属性和方法</h4><p>这些就需要在测试代码中引入同款，以及通过mount的配置项mocks和stubs，分别对其进行mock或者存根了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> Mint <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;mint-ui&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../filter&#x27;</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br>Vue.use(Mint)<br>Vue.prototype.$post = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> axios.post(url, params).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.data)<br>&#125;<br>Vue.filter(<span class="hljs-string">&#x27;filterxxx&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-comment">// bala bala ba…</span><br>&#125;)<br><br><span class="hljs-comment">// xxx.spec.js</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../../filter/filter&#x27;</span>   <span class="hljs-comment">// 引入注册同款过滤器</span><br>Vue.filter(<span class="hljs-string">&#x27;filterxxx&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-comment">// bala bala ba…</span><br>&#125;)<br><span class="hljs-keyword">import</span> &#123; $post &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./http.js&#x27;</span> <br>it(<span class="hljs-string">&#x27;快照测试&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> wrapper = shallowMount(ProductPay, &#123;<br>      mocks: &#123;<br>        $post  <span class="hljs-comment">// 用自己定义的mock数据取代真实http请求</span><br>      &#125;,<br>      stubs:[<span class="hljs-string">&#x27;mt-header&#x27;</span>] <span class="hljs-comment">// 存根组件</span><br>    &#125;)<br>    <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>通常其他测试文件也会依赖这些全局变量，我们可以通过<a href="https://jestjs.io/docs/zh-Hans/configuration#setupfiles-array">配置jest的setupFiles</a>实现复用。</p><h3 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h3><p>我翻开代码一看，这代码没有注释，歪歪斜斜的每一行都写着‘断言正确’四个字。我横竖睡不着，仔细看了半夜，才从字缝里看出字来，满屏都写着两个字：‘造假’！</p><p>正应了那一句：人(ce)生(shi)如戏，全靠演技(mock)。总之，mock老重要了。</p><h4 id="1-mock-简单函数"><a href="#1-mock-简单函数" class="headerlink" title="1. mock 简单函数"></a>1. mock 简单函数</h4><p>我们从最简单的mock一个函数开始。  </p><p>比如我们现在想要测试：当用户购买成功，期望页面能跳转到结果页。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// productpay.vue</span><br>&lt;script&gt;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">onCommmit</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.$post(<span class="hljs-string">&#x27;xxx&#x27;</span>, params).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.$router.push(<span class="hljs-string">`/payresult`</span>)<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>那么，我们可以通过mock掉$router的push方法，然后断言它有被调用且参数正确，达成测试目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// productpay.spec.js</span><br>it(<span class="hljs-string">&#x27;当用户购买成功后，页面应该跳转至结果页&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> mockFunc = jest.fn()<br>  <span class="hljs-keyword">const</span> wrapper = shallowMount(ProductPay, &#123;<br>    mocks: &#123;<br>      $post,<br>      $router: &#123;<br>        push: mockFunc<br>      &#125;<br>    &#125;<br>  &#125;)<br>  wrapper.vm.commmit() <span class="hljs-comment">// 提交购买</span><br>  expect(mockFunc).toHaveBeenCalledWith(<span class="hljs-string">&#x27;/payresult&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="2-mock-Http请求，指定返回结果"><a href="#2-mock-Http请求，指定返回结果" class="headerlink" title="2. mock Http请求，指定返回结果"></a>2. mock Http请求，指定返回结果</h4><p>http请求和上面例子中的$router的区别是，它需要返回值。jest有多种方式指定返回值，这里用的是mockImplementation。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// test/**.spec.js</span><br>it(<span class="hljs-string">&#x27;当用户xxxx，应该xxxx&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br><span class="hljs-keyword">const</span> respSuccess = &#123; <span class="hljs-attr">data</span>: [...], <span class="hljs-attr">code</span>:<span class="hljs-number">0</span> &#125;<br><span class="hljs-keyword">const</span> respError = &#123; <span class="hljs-attr">data</span>: [...], <span class="hljs-attr">code</span>:<span class="hljs-number">888</span> &#125;<br><span class="hljs-comment">// 定义mock函数</span><br><span class="hljs-keyword">const</span> mockPost = jest.fn() <br><span class="hljs-keyword">const</span> wrapper = shallowMount(index, &#123; <br>   mocks: &#123;<br>        $post:mockPost <span class="hljs-comment">// 应用该mock函数</span><br>        &#125;<br>   &#125;)<br>   <span class="hljs-comment">// 指定异步返回数据</span><br>   mockPost.mockImplementation(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Promise</span>.resolve(respError))<br>   <span class="hljs-comment">// 可以对调用情况进行断言</span><br>   expect(mockPost).toHaveBeenCalled() <br>  <br>   mockPost.mockImplementation(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Promise</span>.resolve(respSuccess))<br>   <span class="hljs-comment">//也可以等待异步结束，对结果进行断言</span><br>   <span class="hljs-keyword">await</span> flushPromises()<br>   expect(wrapper.vm.list).toEqual(respSuccess.data)<br>&#125;)<br></code></pre></td></tr></table></figure><p>实际上我们项目中调用的接口会很多，且不乏返回大量数据的情况。如果这些都定义在测试代码里就会很臃肿。这时候，我们可以对该功能做个简单的模块化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 常见的业务代码</span><br><span class="hljs-comment">// main.js中把axios挂载到了vue实例</span><br>Vue.prototype.$post = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> axios.post(url, params).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.data)<br>&#125;<br><span class="hljs-comment">// Index.vue中的请求</span><br>getProductList () &#123;<br>    <span class="hljs-built_in">this</span>.$post(<span class="hljs-string">&#x27;/ProductListQry&#x27;</span>, &#123;&#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.ProductList = data.List<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 在单独js中存放模拟数据 data/ProductListQry.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>data:[&#123; <span class="hljs-attr">id</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;name&#x27;</span>,...&#125;,...],<br>code:<span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// 2. 定义post方法，并做个数据匹配 test/http.js</span><br><span class="hljs-keyword">import</span> ProductListQry <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/data/ProductListQry.js&#x27;</span><br><span class="hljs-keyword">const</span> mockData = &#123;<br>  ProductListQry,<br>  ... <span class="hljs-comment">//可以用同样的方式引入更多mock数据</span><br>&#125;<br><span class="hljs-keyword">const</span> $post = <span class="hljs-function">(<span class="hljs-params">url = <span class="hljs-string">&#x27;&#x27;</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> jsName = <span class="hljs-built_in">String</span>(url).split(<span class="hljs-string">&#x27;/&#x27;</span>)[<span class="hljs-number">1</span>]<br>    resolve(mockData[jsName])<br>  &#125;)<br>&#125;<br><span class="hljs-keyword">export</span> &#123; $post &#125;<br><br><span class="hljs-comment">// 3. 引入并使用 test/index.spec.js</span><br><span class="hljs-keyword">import</span> Index <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/views/Index.vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; $post &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./http.js&#x27;</span><br>it(<span class="hljs-string">&#x27;...&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> wrapper = shallowMount(Index, &#123;<br>      mocks: &#123;<br>        $post<br>      &#125;<br>    &#125;)<br>    wrapper.vm.getProductList() <span class="hljs-comment">//触发请求</span><br>    <span class="hljs-keyword">await</span> flushPromises() <span class="hljs-comment">//等待异步请求结束</span><br>    <span class="hljs-comment">//可以看到wrapper中就有了我们指定的模拟数据</span><br>    <span class="hljs-built_in">console</span>.log(wrapper.vm.ProductList) <br>&#125;)<br></code></pre></td></tr></table></figure><p>同理，如果要测试请求失败的情形，可以再定义一个返回错误数据的方法，比如就叫$postError。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// test/**.spec.js</span><br><span class="hljs-keyword">import</span> &#123; $postError &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./http.js&#x27;</span><br>it(<span class="hljs-string">&#x27;...&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> wrapper = shallowMount(Index, &#123;<br>        mocks: &#123;<br>            $post:$postError<br>        &#125;<br>    &#125;)<br>    <br>    wrapper.vm.getProductList() <span class="hljs-comment">//触发请求</span><br>    <span class="hljs-keyword">await</span> flushPromises() <span class="hljs-comment">//等待异步请求结束</span><br>    <br>    <span class="hljs-comment">// 我们就可以就获取到错误数据的场景进行测试了</span><br>    <span class="hljs-built_in">console</span>.log(wrapper.vm.ProductList) <br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="3-mock-整个模块"><a href="#3-mock-整个模块" class="headerlink" title="3. mock 整个模块"></a>3. mock 整个模块</h4><p>当业务代码中直接使用了引入的组件/方法时，我们对其测试可能就需要mock整个模块。<br>下面是一个用弹窗做表单验证的场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// productpay.vue</span><br>&lt;script&gt;<br><span class="hljs-keyword">import</span> &#123; MessageBox &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../Component&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    methods:&#123;<br>        makeSurebuy () &#123;<br>            <span class="hljs-keyword">let</span> payAmount = delcommafy(<span class="hljs-built_in">this</span>.payAmount)<br>                <span class="hljs-keyword">if</span> (!payAmount) &#123;<br>                    MessageBox(&#123;<br>                    message: <span class="hljs-string">&#x27;请先输入购买金额&#x27;</span><br>                &#125;)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (payAmount &lt; <span class="hljs-built_in">this</span>.resData.BaseAmt) &#123;<br>                MessageBox(&#123;<br>                    message: <span class="hljs-string">&#x27;购买金额不能小于起存金额&#x27;</span><br>                &#125;)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (payAmount &gt; <span class="hljs-built_in">this</span>.Balance) &#123;<br>                MessageBox(&#123;<br>                    message: <span class="hljs-string">&#x27;购买金额不能大于可用余额&#x27;</span><br>                &#125;)<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-comment">// 校验通过，发起交易...</span><br>        &#125;<br>    &#125;<br>&#125;<br>&lt;script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//productpay.spce.js</span><br><span class="hljs-keyword">import</span> Component <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../Component&#x27;</span><br>jest.mock(<span class="hljs-string">&#x27;../../../components/ZyComponent&#x27;</span>)<br><br>it(<span class="hljs-string">&#x27;当用户点击购买按钮，如果输入非法金额，应该有相应的错误提示&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    wrapper.findAll(<span class="hljs-string">&#x27;.btn-commit&#x27;</span>).at(<span class="hljs-number">0</span>).trigger(<span class="hljs-string">&#x27;click&#x27;</span>)<br>    expect(Component.MessageBox.mock.calls[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br>        .toEqual(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请先输入购买金额&#x27;</span> &#125;)<br>    <br>    wrapper.setData(&#123;<span class="hljs-attr">payAmount</span>: <span class="hljs-string">&#x27;100&#x27;</span>&#125;)<br>    <br>    wrapper.findAll(<span class="hljs-string">&#x27;.btn-commit&#x27;</span>).at(<span class="hljs-number">0</span>).trigger(<span class="hljs-string">&#x27;click&#x27;</span>)<br>    expect(Component.MessageBox.mock.calls[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br>        .toEqual(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;购买金额不能小于起存金额&#x27;</span> &#125;)<br>    <br>    wrapper.setData(&#123;<span class="hljs-attr">payAmount</span>: <span class="hljs-string">&#x27;100000000000000000&#x27;</span>&#125;)<br>    <br>    wrapper.findAll(<span class="hljs-string">&#x27;.btn-commit&#x27;</span>).at(<span class="hljs-number">0</span>).trigger(<span class="hljs-string">&#x27;click&#x27;</span>)<br>    expect(Component.MessageBox.mock.calls[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>])<br>        .toEqual(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;购买金额不能大于可用余额&#x27;</span> &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>我们通过jest.mock() mock整个模块，当该模块的方法被调用后它就会有一个mock属性，可以通过ZyComponent.ZyMessageBox.mock进行访问，其中ZyComponent.ZyMessageBox.mock.calls会返回被调用情况的数组，我们可以根据这个数据对函数被调用次数、入参情况进行断言测试。</p><h3 id="Stub存根组件"><a href="#Stub存根组件" class="headerlink" title="Stub存根组件"></a>Stub存根组件</h3><p>进行单元测试，理论上我们不用、也不应该在它的测试用例中测试子组件，不然就叫集成测试了。<br>vue-test-utils是通过配置stubs实现对组件mock的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> wrapper = shallowMount(index, &#123;<br>    stubs: [<span class="hljs-string">&#x27;mt-header&#x27;</span>, <span class="hljs-string">&#x27;mt-loadmore&#x27;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>但是业务中难免会有调用子组件方法的时候，比如说mint-ui的loadmore。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// procuctlist.vue</span><br>&lt;script&gt;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">getProductList</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.$post(<span class="hljs-string">&#x27;xxx&#x27;</span>, params).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.productList = <span class="hljs-built_in">this</span>.productList.concat(data.List)<br>        <span class="hljs-built_in">this</span>.$refs.loadmore.onBottomLoaded() <span class="hljs-comment">// 这个</span><br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>这时候我们是可以改用mount方法使页面渲染子组件，这样通过$refs就能正常的获取到子组件实例。但更合适的做法应该是自定义存根组件的内部实现，以满足测试需求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// procuctlist.spec.js</span><br>it(<span class="hljs-string">&#x27;当用户上拉产品列表，应该能看到的更多的产品&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> mockOnBottomLoaded = jest.fn()<br>    <span class="hljs-keyword">const</span> mtLoadMore = &#123;<br>      render: <span class="hljs-function">() =&gt;</span> &#123; &#125;,<br>      methods: &#123;<br>        onBottomLoaded: mockOnBottomLoaded<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> mtHeader = &#123;<br>      render: <span class="hljs-function">() =&gt;</span> &#123; &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> wrapper = shallowMount(Index, &#123;<br>      stubs: &#123; <span class="hljs-string">&#x27;mt-loadmore&#x27;</span>: mtLoadMore, <span class="hljs-string">&#x27;mt-header&#x27;</span>: mtHeader &#125;,<br>      mocks: &#123;<br>        $post<br>      &#125;<br>    &#125;)<br>    <span class="hljs-keyword">const</span> currentPage = wrapper.vm.currentPage<br><br>    wrapper.vm.loadMoreProduction()<br><br>    expect(wrapper.vm.currentPage).toEqual(currentPage + <span class="hljs-number">1</span>)<br>    expect(mockOnBottomLoaded).toHaveBeenCalled()<br>&#125;)<br></code></pre></td></tr></table></figure><p>最后提一嘴，存根组件后，业务代码中子组件还是会被引入的，只是没有被实例化和渲染。</p><h3 id="Configuring和CLI"><a href="#Configuring和CLI" class="headerlink" title="Configuring和CLI"></a>Configuring和CLI</h3><h4 id="1-统计代码覆盖率忽略某些文件"><a href="#1-统计代码覆盖率忽略某些文件" class="headerlink" title="1. 统计代码覆盖率忽略某些文件"></a>1. 统计代码覆盖率忽略某些文件</h4><p>Jest有提供对应的配置项coveragePathIgnorePatterns，但是在使用后并未生效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// jest.config.js</span><br>&#123;<br>    coveragePathIgnorePatterns: [<span class="hljs-string">&#x27;&lt;rootDir&gt;/src/assets/&#x27;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>最后从<a href="https://jestjs.io/docs/zh-Hans/troubleshooting#coveragepathignorepatterns-seems-to-not-have-any-effect">官方文档</a>中得知是babel-plugin-istanbul插件造成的。当使用 babel-plugin-istanbul 时，babel 处理的每个文件都有覆盖率收集代码，因此 coveragePathIgnorePatterns 不会忽略它。<br>babel-plugin-istanbul插件有提供<a href="https://www.npmjs.com/package/babel-plugin-istanbul">exclude配置项</a>以解决这个问题，但并不是我想要的。最终选择了在.balelrc中把istanbul注释掉了。</p><h4 id="2-通过t模式，可以仅执行指定的测试用例"><a href="#2-通过t模式，可以仅执行指定的测试用例" class="headerlink" title="2. 通过t模式，可以仅执行指定的测试用例"></a>2. 通过t模式，可以仅执行指定的测试用例</h4><p>当测试用例写的多了，每次执行跑一堆用例，效率很低，如果代码里有很多console, 那就更难受了，找个报错都能找半天。当时就想如果能仅测试当前用例就好了。<br>然后就找到了t模式，jest命令带–watch参数进入监听模式，然后输入t,再输入匹配规则即可。世界一下子就清净了，舒服……</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// package.json</span><br>&#123;<br>    <span class="hljs-attr">&quot;scripts&quot;</span>:&#123;<br>        <span class="hljs-attr">&quot;tets&quot;</span>:<span class="hljs-string">&quot;jest --watch&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-vue-awesome-swiper测试运行时报错"><a href="#3-vue-awesome-swiper测试运行时报错" class="headerlink" title="3. vue-awesome-swiper测试运行时报错"></a>3. vue-awesome-swiper测试运行时报错</h4><p>如果组件中引入了swiper，那么在执行测试用例时，vue-awesome-swiper中的js会报错。引用即报错，且是第三方代码。<br>最后通过把swiper组件由局部注册改为全局注册得以解决。</p><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>最后列一下在学习过程中看到的对我帮助很大的文章和资料</p><ul><li><a href="https://jestjs.io/zh-Hans/">Jest官方文档</a></li><li><a href="https://vue-test-utils.vuejs.org/zh/">vue-test-utils官方指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/48758013">一篇文章学会 Vue 项目单元测试</a></li><li><a href="https://blog.csdn.net/duola8789/article/details/80434962">Jest结合Vue-test-utils使用的初步实践</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我也统计一下字符串中出现最多的字母与个数</title>
    <link href="/2018/12/16/%E6%88%91%E4%B9%9F%E7%BB%9F%E8%AE%A1%E4%B8%80%E4%B8%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E6%AF%8D%E4%B8%8E%E4%B8%AA%E6%95%B0/"/>
    <url>/2018/12/16/%E6%88%91%E4%B9%9F%E7%BB%9F%E8%AE%A1%E4%B8%80%E4%B8%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E6%AF%8D%E4%B8%8E%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>我在上一篇文章对<a href="https://juejin.im/post/6844903736880414734">JS遍历数据的方法</a>做了总结，现在趁着这个题目实战一下。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>最常规的思路：用变量存储目标字母和个数，循环遍历不断更新结果。知识点：</p><ul><li>new Set(arr) //Set去重,目标字符串长的话去重还是有必要的</li><li>Array.filter() // 筛选得到符合条件的新数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> testStr = <span class="hljs-string">&quot;aaaadddddssssgdhssssbbbbbuuuwmopqlsabcfwsqdghgukssuyutsudddddsasss&quot;</span> <span class="hljs-comment">//其后方案均使用该测试数据</span><br><br><span class="hljs-comment">// 统计字符串中出现最多的字母与个数</span><br><span class="hljs-keyword">const</span> getStrMax = <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> arr = str.split(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//转成数组</span><br>  <span class="hljs-keyword">const</span> arrSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr);<span class="hljs-comment">//去重</span><br><br>  <span class="hljs-keyword">let</span> maxCount = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录最大数量</span><br>  <span class="hljs-keyword">let</span> maxItem = [];<span class="hljs-comment">//记录最大数量的字母，考虑到有重复，用了数组</span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> arrSet.values()) &#123;<br>    <span class="hljs-keyword">const</span> count = arr.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> item === value<br>    &#125;).length;<br>    <span class="hljs-keyword">if</span> (count &gt; maxCount) &#123;<br>      maxCount = count;<br>      maxItem = [value];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count === maxCount) &#123;<br>      maxItem.push(value);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    maxItem,<br>    maxCount<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(getStrMax(testStr))<span class="hljs-comment">//&#123; maxItem: [ &#x27;s&#x27; ], maxCount: 17 &#125;</span><br></code></pre></td></tr></table></figure><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3>思路：先获取每个字母出现的个数，再取出个数最多的那个。知识点：   </li><li>Array.map() //遍历原数组得到想要的新数组</li><li>[…new Set(arr)] //扩展运算符,用于set结构转数组</li><li>Array.sort() //数组排序<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//获取每个字母的数量</span><br><span class="hljs-keyword">const</span> getResult = <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> arr = str.split(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//转成数组</span><br>  <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>(arr)].map(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> count = arr.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> item === value<br>    &#125;).length<br>    <span class="hljs-keyword">return</span> &#123;<br>      value,<br>      count<br>    &#125;<br>  &#125;)<br>&#125;<br><span class="hljs-comment">//按count从大到小排序</span><br><span class="hljs-keyword">const</span> result = getResult(testStr).sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> b.count - a.count<br>&#125;)<br><span class="hljs-comment">//第一个就是结果</span><br><span class="hljs-built_in">console</span>.log(result[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3>思路：同方案二，只是应用reduce方法，减少了代码量。知识点：</li><li>Array.reduce() //遍历数组并累加指定的数据</li><li>Array.from() //类数组对象转数组</li><li>Object.entries() //对象转数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> getByReduce = <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(str).reduce(<span class="hljs-function">(<span class="hljs-params">obj, v</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> objVal = obj[v] || <span class="hljs-number">0</span>;<br>    objVal === <span class="hljs-number">0</span> ? obj[v] = <span class="hljs-number">1</span> : obj[v] = objVal + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;, &#123;&#125;);<br>&#125;<br><span class="hljs-comment">//转数组然后排序</span><br><span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Object</span>.entries(getByReduce(testStr)).sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>]<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(arr[<span class="hljs-number">0</span>]);<span class="hljs-comment">//[ &#x27;s&#x27;, 17 ]</span><br></code></pre></td></tr></table></figure><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3></li><li>吾爱吾码，但更爱真理。如有不正确或脱了裤子放屁的操作敬请指出。温柔些，脸皮薄……</li><li>如有其他更好、炫酷抑或有趣的方案，欢迎评论留言。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS遍历方法总结</title>
    <link href="/2018/12/12/JS%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2018/12/12/JS%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>来来来，新鲜出炉的js遍历总结，比我菜的都看一下。保你戒掉循环，告别模棱两可，达到灵活操作数据的高潮。</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> data = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = data.length; i &lt; len; i++) &#123;<br>  <span class="hljs-built_in">console</span>.log(i);<span class="hljs-comment">// 0 1 2 3</span><br>  <span class="hljs-built_in">console</span>.log(data[i]);<span class="hljs-comment">// a b c d </span><br>&#125;<br></code></pre></td></tr></table></figure><p>适用范围：Array、String<br>点评：性能最高但不够优雅</p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> data = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>];<br>data.forEach(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(v);<span class="hljs-comment">// a b c d </span><br>  <span class="hljs-built_in">console</span>.log(i);<span class="hljs-comment">// 0 1 2 3</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>适用范围：Array、Set、Map<br>点评：无法中途跳出循环，break命令或return命令都不能奏效。</p><h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> data = &#123; <span class="hljs-attr">key1</span>: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-attr">key2</span>: <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-attr">key3</span>: <span class="hljs-string">&quot;c&quot;</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> data) &#123;<br>  <span class="hljs-built_in">console</span>.log(key); <span class="hljs-comment">// key1 key2 key3 </span><br>  <span class="hljs-built_in">console</span>.log(data[key]); <span class="hljs-comment">// a b c   </span><br>&#125;<br><span class="hljs-keyword">const</span> data = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">in</span> data) &#123;<br>  <span class="hljs-built_in">console</span>.log(index); <span class="hljs-comment">// 0 1 2 3  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>适用范围：Array、Object、String<br>点评：会枚举原型属性，就是说会遍历来自继承对象的可枚举属性</p><h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> data = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> data) &#123;<br>  <span class="hljs-built_in">console</span>.log(item); <span class="hljs-comment">// a b c d  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>适用范围：Array、String、Set、Map<br>点评：ES6新增的作为遍历所有数据结构的统一的方法。唯一的缺点也许就是兼容性了吧。</p><h3 id="Array-filter"><a href="#Array-filter" class="headerlink" title="Array.filter()"></a>Array.filter()</h3><p>返回一个新数组，数组中的元素为原始数组中符合条件的所有项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//筛选出包含_mgt的项</span><br><span class="hljs-keyword">const</span> limits = [<span class="hljs-string">&quot;member_mgt&quot;</span>, <span class="hljs-string">&quot;member_audit&quot;</span>, <span class="hljs-string">&quot;recommend_mgt&quot;</span>, <span class="hljs-string">&quot;dictionary_mgt&quot;</span>]<br><span class="hljs-keyword">const</span> result = limits.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> item.indexOf(<span class="hljs-string">&quot;_mgt&quot;</span>) &gt; -<span class="hljs-number">1</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(result)<span class="hljs-comment">// [ &#x27;member_mgt&#x27;, &#x27;recommend_mgt&#x27;, &#x27;dictionary_mgt&#x27; ]</span><br></code></pre></td></tr></table></figure><p>适用于想从源数据中筛选/提取出指定数据的业务场景。</p><h3 id="Array-map"><a href="#Array-map" class="headerlink" title="Array.map()"></a>Array.map()</h3><p>返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//数组中所有值转大写</span><br><span class="hljs-keyword">const</span> limits = [<span class="hljs-string">&quot;member_mgt&quot;</span>, <span class="hljs-string">&quot;member_audit&quot;</span>, <span class="hljs-string">&quot;recommend_mgt&quot;</span>, <span class="hljs-string">&quot;dictionary_mgt&quot;</span>]<br><span class="hljs-keyword">const</span> result = limits.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> item.toLocaleUpperCase()<br>&#125;)<br><span class="hljs-built_in">console</span>.log(result)<span class="hljs-comment">// [ &#x27;MEMBER_MGT&#x27;,&#x27;MEMBER_AUDIT&#x27;,&#x27;RECOMMEND_MGT&#x27;,&#x27;DICTIONARY_MGT&#x27; ]</span><br></code></pre></td></tr></table></figure><p>适用于要对源数据进行加工或修改的业务场景</p><h3 id="Array-some"><a href="#Array-some" class="headerlink" title="Array.some()"></a>Array.some()</h3><p>检测所有元素是否满足条件，并返回一个Boolean值。 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。如果没有满足条件的元素，则返回false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//判断是否有member_mgt的权限</span><br><span class="hljs-keyword">const</span> limits = [<span class="hljs-string">&quot;member_mgt&quot;</span>, <span class="hljs-string">&quot;member_audit&quot;</span>, <span class="hljs-string">&quot;recommend_mgt&quot;</span>, <span class="hljs-string">&quot;dictionary_mgt&quot;</span>]<br><span class="hljs-keyword">const</span> result = limits.some(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> item === <span class="hljs-string">&quot;member_mgt&quot;</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(result)<span class="hljs-comment">// true</span><br><span class="hljs-comment">//这个效果其实等同于limits.includes(&quot;member_mgt&quot;) 这里只是为了举例</span><br></code></pre></td></tr></table></figure><h3 id="Array-every"><a href="#Array-every" class="headerlink" title="Array.every()"></a>Array.every()</h3><p>检测所有元素是否满足条件，并返回一个Boolean值。 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。如果所有元素都满足条件，则返回 true。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//判断数组中的值是否均为字符串</span><br><span class="hljs-keyword">const</span> limits = [<span class="hljs-string">&quot;member_mgt&quot;</span>, <span class="hljs-string">&quot;member_audit&quot;</span>, <span class="hljs-string">&quot;recommend_mgt&quot;</span>, <span class="hljs-string">&quot;dictionary_mgt&quot;</span>]<br><span class="hljs-keyword">const</span> result = limits.every(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&quot;string&quot;</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(result)<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="总结发言"><a href="#总结发言" class="headerlink" title="总结发言"></a>总结发言</h3><ul><li>其实，支持对象遍历的方法只有for…in，不过可以通过Object.keys()、Object.values()、Object.entries()等方法将对象转成数组后再操作。   </li><li>其实，遍历的目的无外乎是对数据进行筛选、重组抑或是判断，只要熟练使用数组的那4个方法就能满足几乎所有的应用场景。消灭循环从我做起，加油！</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一个开源项目</title>
    <link href="/2018/12/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    <url>/2018/12/02/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>我想，每个程序员都有一个“开源”梦，这是我的第一步。</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>如题，本文会详实的记录我做accurate-math这个开源项目的全过程，每一条命令、每一行代码、每一处细节。<br>先简单介绍下accurate-math项目：一个极简js库，用于解决js浮点数四则运算结果不准确的问题。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log(<span class="hljs-number">0</span>.<span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">2</span>); // <span class="hljs-number">0</span>.<span class="hljs-number">30000000000000004</span><br><span class="hljs-attribute">console</span>.log(<span class="hljs-number">0</span>.<span class="hljs-number">14</span> / <span class="hljs-number">0</span>.<span class="hljs-number">2</span>); // <span class="hljs-number">0</span>.<span class="hljs-number">7000000000000001</span><br><span class="hljs-attribute">console</span>.log(<span class="hljs-number">1</span> - <span class="hljs-number">0</span>.<span class="hljs-number">8</span>); // <span class="hljs-number">0</span>.<span class="hljs-number">19999999999999996</span> <br><span class="hljs-attribute">console</span>.log(<span class="hljs-number">6</span> * <span class="hljs-number">0</span>.<span class="hljs-number">7</span>); // <span class="hljs-number">4</span>.<span class="hljs-number">199999999999999</span> <br><span class="hljs-attribute">console</span>.log(<span class="hljs-number">0</span>.<span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">2</span>); // <span class="hljs-number">0</span>.<span class="hljs-number">30000000000000004</span> <br><span class="hljs-attribute">console</span>.log(<span class="hljs-number">0</span>.<span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">7</span>); // <span class="hljs-number">0</span>.<span class="hljs-number">7999999999999999</span> <br><span class="hljs-attribute">console</span>.log(<span class="hljs-number">1</span>.<span class="hljs-number">2</span> / <span class="hljs-number">0</span>.<span class="hljs-number">2</span>); // <span class="hljs-number">5</span>.<span class="hljs-number">999999999999999</span><br></code></pre></td></tr></table></figure><p>用到的技术：git、npm、webpack、javascript。</p><h2 id="一、在github创建项目"><a href="#一、在github创建项目" class="headerlink" title="一、在github创建项目"></a>一、在github创建项目</h2><p>在github上新建项目并克隆到本地。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/qq9694526/</span>accurate-math.git<br></code></pre></td></tr></table></figure><p>备注：1.创建项目的名字，一定要在github和npm上都搜索一下，确保<strong>无重名</strong>，否则会影响最终在npm上的发布。2. .gitignore选择Node。</p><h2 id="二、项目构建"><a href="#二、项目构建" class="headerlink" title="二、项目构建"></a>二、项目构建</h2><ol><li>npm初始化项目<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">cnpm init -y <br></code></pre></td></tr></table></figure></li><li>安装webpack<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">cnpm i --save-dev webpack webpack-cli webpack-dev-server<br></code></pre></td></tr></table></figure></li><li>创建目录<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">mkdir release src example<br></code></pre></td></tr></table></figure></li><li>新建文件</li></ol><ul><li>在根目录下新建webpack.config.js ，内容如下：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  output: &#123;<br>    path: path.resolve(__dirname, <span class="hljs-string">&#x27;release&#x27;</span>),<br>    filename: <span class="hljs-string">&#x27;accurate-math.js&#x27;</span><br>  &#125;,<br>  devServer: &#123;<br>    contentBase: path.join(__dirname, <span class="hljs-string">&quot;./&quot;</span>),<br>    compress: <span class="hljs-literal">true</span>,<br>    port: <span class="hljs-number">9000</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>在src目录下新建index.js。这里先建好，内容在随后的开发阶段再填充。</li><li>在example目录下新建demo.html，同上。</li></ul><ol start="5"><li>在package.json中配置快捷命令<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,<br>  <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack&quot;</span>,<span class="hljs-comment">// 压缩打包</span><br>  <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;webpack-dev-server --open&quot;</span> <span class="hljs-comment">// 示例用的web服务</span><br>&#125;,<br></code></pre></td></tr></table></figure><h2 id="三、项目开发"><a href="#三、项目开发" class="headerlink" title="三、项目开发"></a>三、项目开发</h2></li><li>功能开发</li></ol><ul><li>在src/index.js中添加add、sub、mul、div这四个方法，分别对应js四则运算中的加减乘数。具体代码就不贴了，有兴趣的参看<a href="https://github.com/qq9694526/accurate-math/blob/master/src/index.js">src/index.js</a></li><li>使用webpack对代码进行压缩打包，生成accurate-math.js。<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-builtin-name">run</span> build <br></code></pre></td></tr></table></figure></li><li>在根目录下创建index.js，供npm安装使用。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">&#x27;use strict&#x27;</span><br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./release/accurate-math.js&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>编写示例</li></ol><ul><li>在example/demo.html中编写示例，测试使用4种方法。详情见github的<a href="https://github.com/qq9694526/accurate-math/blob/master/example/demo.html">example/demo.html</a></li><li>启动web服务后， 浏览器访问<a href="http://localhost:9000/example/demo.html%EF%BC%8C%E6%9F%A5%E7%9C%8B%E7%A4%BA%E4%BE%8B%E5%8F%8A%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E3%80%82">http://localhost:9000/example/demo.html，查看示例及测试结果。</a><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-builtin-name">run</span> start <br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>完善README<br>Readme是开源项目的一张脸，用户的第一印象。一个好的Readme应该包含产品简介、产品安装和下载、快速使用、交流提问区、关于作者等信息，且要足够简练。<br>详情见github的<a href="https://github.com/qq9694526/accurate-math/blob/master/README.md">Readme.md</a></p></li><li><p>提交至远程仓库</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -am <span class="hljs-string">&quot;first commit&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>打个标签，标记发布结点，以示重要。它对应着github远程库上的releases。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> tag -a &#x27;v<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>&#x27; -m &#x27;v<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>&#x27;<br><br><span class="hljs-attribute">git</span> push origin v<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="四、发布到npm"><a href="#四、发布到npm" class="headerlink" title="四、发布到npm"></a>四、发布到npm</h2></li><li><p>npm身份认证</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm add user<br><br>npm login<br></code></pre></td></tr></table></figure></li><li><p>通过邮箱验证后，执行发布命令。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> publish .<br></code></pre></td></tr></table></figure><p>备注：npm发布后撤销会非常麻烦，请务必充分测试和再三检查readme，确认无误。</p><h2 id="五、使用体验"><a href="#五、使用体验" class="headerlink" title="五、使用体验"></a>五、使用体验</h2><p>至此，咱们或者其他用户就可以通过npm安装并使用咱们自己刚刚编写的accurate-math插件了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm i accurate-math -D<br><br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;accurate-math&quot;</span>)<br></code></pre></td></tr></table></figure><p>满满的成就感！！！</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2></li></ol><ul><li>GitHub<br>欢迎前往star[娇羞]。<br><a href="https://github.com/qq9694526/accurate-math">github：</a><a href="https://github.com/qq9694526/accurate-math">https://github.com/qq9694526/accurate-math</a> </li><li>NPM<br>虽然能用且好用，但还是不推荐，因为已经有很多<a href="https://github.com/MikeMcl">成熟类库</a>的实现了。我这次就是体验一下开源的这个过程。<br><a href="https://www.npmjs.com/package/accurate-math">npm：</a><a href="https://www.npmjs.com/package/accurate-math">https://www.npmjs.com/package/accurate-math</a> </li><li>参考资料<br><a href="https://blog.csdn.net/tianwailaikewbb/article/details/50435403?utm_source=blogxgwz1">https://blog.csdn.net/tianwailaikewbb/article/details/50435403?utm_source=blogxgwz1</a><br><a href="https://www.cnblogs.com/junjieok/p/3306155.html">https://www.cnblogs.com/junjieok/p/3306155.html</a><br><a href="https://www.imooc.com/article/28240">https://www.imooc.com/article/28240</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VUE开发微信H5页面总结</title>
    <link href="/2018/12/02/VUE%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1H5%E9%A1%B5%E9%9D%A2%E6%80%BB%E7%BB%93/"/>
    <url>/2018/12/02/VUE%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1H5%E9%A1%B5%E9%9D%A2%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>刚入门前端的时候写过很多的微信H5页面，时隔多年感觉应该是手到擒来，不曾想竟很是费了一些功夫。现在把本次开发过程中遇到的问题以及我是如何解决的，做个记录。防止自己以后再去解决解决过的问题。<br><strong>github</strong>：<a href="https://github.com/qq9694526/vue-wxh5">https://github.com/qq9694526/vue-wxh5</a></p><h2 id="一、微信网页授权"><a href="#一、微信网页授权" class="headerlink" title="一、微信网页授权"></a>一、微信网页授权</h2><p>网页授权流程分为四步，这里只说前端需要做的，其中的第一步：跳转授权页面获取code。<br>这里分享下我的授权逻辑（下图），它有两个优点：   </p><ol><li>授权跳转在dom渲染之前，体验会好一些；   </li><li>本地存储了openId，前后端均不用频繁的与微信服务器交互。  </li></ol><p> <img src="/img/wx-aouth.jpeg" alt="微信授权流程图"></p><h2 id="二、微信jssdk授权"><a href="#二、微信jssdk授权" class="headerlink" title="二、微信jssdk授权"></a>二、微信jssdk授权</h2><p>如果你页面中有用到分享、上传图片、微信支付等功能，那么需要先进行js-sdk授权。我这边封装成了2个方法：initConfig和setShare，方便在路由/页面切换的时候重复调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//main.js</span><br><span class="hljs-keyword">import</span> wxsdk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./config/wxsdk.js&#x27;</span> <span class="hljs-comment">//该模块提供initConfig和setShare方法，具体代码太长见github</span><br>Vue.prototype.wxsdk = wxsdk;<span class="hljs-comment">//挂载到全局</span><br><br><span class="hljs-comment">//使用</span><br> <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;<br>   <span class="hljs-built_in">this</span>.wxsdk.initConfig(location.href.split(<span class="hljs-string">&quot;#&quot;</span>)[<span class="hljs-number">0</span>], <span class="hljs-function">() =&gt;</span> &#123;<br>     <span class="hljs-built_in">this</span>.wxsdk.setShare(<span class="hljs-built_in">this</span>.user.openId);<br>    &#125;);<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="三、webpack-dev-server解决跨域"><a href="#三、webpack-dev-server解决跨域" class="headerlink" title="三、webpack-dev-server解决跨域"></a>三、webpack-dev-server解决跨域</h2><p>讲真的所有跨域解决方案都必须有服务端的参与，诚然这个问题是浏览器抛出的，但让前端去解决真的很冤。下面两个配置让你永远告别跨域烦恼。本地开发用webpack-dev-server，测试生产环境用nginx。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//接口根路径http://47.105.59.***:9090/zt-wx</span><br><span class="hljs-comment">//以vue-cli搭建的项目config举例 config/index.js</span><br>  dev: &#123;<br>    proxyTable: &#123;<br>      <span class="hljs-string">&#x27;/zt-wx&#x27;</span>: &#123;<br>        target: <span class="hljs-string">&#x27;http://47.105.59.***:9090&#x27;</span>,  <span class="hljs-comment">//目标接口域名</span><br>        changeOrigin: <span class="hljs-literal">true</span>  <span class="hljs-comment">//是否跨域</span><br>      &#125;<br>    &#125;,<br>  &#125;<br><span class="hljs-comment">//实际发起请求时的url</span><br><span class="hljs-built_in">this</span>.http.get(<span class="hljs-string">`/zt-wx/api/wx/info`</span>).then(); <span class="hljs-comment">//http是我自己对axios的再封装  </span><br><br><span class="hljs-comment">//nginx代理配置</span><br>server &#123;<br>    location /zt-wx &#123;<br>proxy_pass http:<span class="hljs-comment">//47.105.59.***:9090;</span><br>    &#125;<br>&#125;        <br></code></pre></td></tr></table></figure><h2 id="四、iso初次加载白屏、跳转白屏"><a href="#四、iso初次加载白屏、跳转白屏" class="headerlink" title="四、iso初次加载白屏、跳转白屏"></a>四、iso初次加载白屏、跳转白屏</h2><p><strong>问题现象</strong>： ios页面初次加载白屏，刷新后正常，但切换到其他页面再后退，又会白屏。<br><strong>问题原因</strong>：在ios机器上使用webview开发Vue项目时候，go history(-1)，无法将body的高度拉掉，使得内容被遮住了。<br><strong>解决办法</strong>：html，body都是100%，#app撑起了父元素的告诉，但是浏览器默认的滚动scroll并不是#app，而是body,某些因素，造成返回history 后，无法复原（ios 的锅），为此，我们将#app进行了绝对定位，并让它重新成为 scroll 的对象，从而解决问题。   </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#app</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">overflow</span>: scroll;<br>  -webkit-<span class="hljs-attribute">overflow</span>-scrolling: touch;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考资料：<a href="https://blog.csdn.net/guxuehua/article/details/79026655">https://blog.csdn.net/guxuehua/article/details/79026655</a></p><h2 id="五、ios路由-跳转页面后分享失效"><a href="#五、ios路由-跳转页面后分享失效" class="headerlink" title="五、ios路由/跳转页面后分享失效"></a>五、ios路由/跳转页面后分享失效</h2><p><strong>问题现象</strong>：ios微信路由到另一个页面选择图片OK，但分享失效，刷新这个页面分享就正常了。<br>已累计尝试解决超过8小时，至今未果。<br>参考资料：<a href="https://www.zhihu.com/question/59388458/answer/340351305">https://www.zhihu.com/question/59388458/answer/340351305</a></p><h2 id="六、上传图片报错：处理异常"><a href="#六、上传图片报错：处理异常" class="headerlink" title="六、上传图片报错：处理异常"></a>六、上传图片报错：处理异常</h2><p>这个报错甚是诡异，因为前端和后端代码均没有“处理异常”这4个字。本来想甩锅给微信不管了的，但随后在做限制上传图片大小功能的时候阴差阳错的给解决了。<br><strong>问题原因</strong>：后端tomcat服务默认设置表单提交数据大小上限为2M，大于2M就会报错。<br><strong>解决办法</strong>：后端大神把server.xml中maxPostSize的值改为-1后解决。<br>参考资料：<a href="https://blog.csdn.net/w18756901575/article/details/79374621">https://blog.csdn.net/w18756901575/article/details/79374621</a></p><h2 id="七、正确导出图片格式"><a href="#七、正确导出图片格式" class="headerlink" title="七、正确导出图片格式"></a>七、正确导出图片格式</h2><p>这个项目首页基本是由图片堆砌成的，一开始切出来的图(默认.png)压缩后在400k-1.3M之间。一开始还以为PSD素材有问题。直到项目最后才闪回，想起图片格式的知识点，改导出成.jpg格式后压缩出来的图片基本控制在100K以内了。具体的.png.jpg这些图片格式的知识有兴趣的自己查。</p><h2 id="八、vuex使用之同步用户信息"><a href="#八、vuex使用之同步用户信息" class="headerlink" title="八、vuex使用之同步用户信息"></a>八、vuex使用之同步用户信息</h2><p>讲道理小项目是不应该用vuex的，但是用着确实爽，即简单又省心省力。由于我总是忘记它的方法名，所以在这里贴下代码，方便以后随时cv。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//config/store.js</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>    state: &#123;<br>        user: &#123;&#125;<br>    &#125;,<br>    mutations：&#123;<br>        <span class="hljs-function"><span class="hljs-title">updateUser</span>(<span class="hljs-params">state, data</span>)</span>&#123;<br>            state.user = data;<br>        &#125;<br>    &#125;<br>&#125;)<br><span class="hljs-comment">//在组件中使用</span><br>computed: &#123;<br>    <span class="hljs-function"><span class="hljs-title">user</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$store.state.user;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//在需要的时候更新数据</span><br><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&quot;updateUser&quot;</span>, user);<br></code></pre></td></tr></table></figure><h2 id="九、使用html2canvas生成的海报不显示图片"><a href="#九、使用html2canvas生成的海报不显示图片" class="headerlink" title="九、使用html2canvas生成的海报不显示图片"></a>九、使用html2canvas生成的海报不显示图片</h2><p><strong>问题原因</strong>：引入的图片资源路径跨域造成的。<br><strong>解决办法</strong>：我先是按照官方给的那个php的方案弄的，未能解决。最后舔着脸让后端大佬把图片资源目录挪到我web服务目录下给解决的。   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//安装</span><br>npm install --save html2canvas<br><span class="hljs-comment">//引入</span><br><span class="hljs-keyword">import</span> html2canvas <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;html2canvas&quot;</span>;<br><span class="hljs-comment">//使用</span><br><span class="hljs-keyword">const</span> myPosterWrap = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;posterWrap&quot;</span>);<br>html2canvas(myPosterWrap).then(<span class="hljs-function"><span class="hljs-params">canvas</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.posterSrc = canvas.toDataURL(<span class="hljs-string">&quot;image/png&quot;</span>);<br>    <span class="hljs-built_in">this</span>.uploadPosterImg(<span class="hljs-built_in">this</span>.posterSrc);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="十、css黑科技之放置指定比例的图片"><a href="#十、css黑科技之放置指定比例的图片" class="headerlink" title="十、css黑科技之放置指定比例的图片"></a>十、css黑科技之放置指定比例的图片</h2><p>就是把不定宽图片按指定比例显示，直接上码（1：1.25）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">//html<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;poster-img-wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;poster-img-place&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;poster-img&quot;</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;user.picAddress&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css">//less<br><span class="hljs-selector-class">.poster-img-wrap</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">28%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>    <span class="hljs-selector-class">.poster-img-place</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>        <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">125%</span>;<br>    &#125;<br>    <span class="hljs-selector-class">.poster-img</span> &#123;<br>        <span class="hljs-attribute">position</span>: absolute;<br>        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十一、ios页面加载不全不能滚动"><a href="#十一、ios页面加载不全不能滚动" class="headerlink" title="十一、ios页面加载不全不能滚动"></a>十一、ios页面加载不全不能滚动</h2><p><strong>问题描述</strong> ：ios从首页进入，跳转其他页面再后退到首页，首页只显示一屏内容且无法滚动。<br><strong>问题原因</strong>：在于ios浏览器内核的别致渲染逻辑：它会预先找到相应的overflow: scroll元素，如果子元素高度高于父元素，则建立原生的scrollView实现滚动。问题就出现在这个“预先”上，它预先获取的高度并不是子元素渲染后的真实高度。<br><strong>解决办法</strong>：给设置了滚动的#app元素下的子元素p-index设置min-height: calc(100% + 1px);</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#app</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">overflow</span>: scroll;<br>  -webkit-<span class="hljs-attribute">overflow</span>-scrolling: touch;<br>&#125;<br><span class="hljs-selector-class">.p-index</span>&#123;<br>   <span class="hljs-attribute">min-height</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span> + <span class="hljs-number">1px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实能解决全靠这篇博文，这里就不赘述了。<a href="https://blog.csdn.net/nongweiyilady/article/details/83039868">https://blog.csdn.net/nongweiyilady/article/details/83039868</a><br>神奇的是，我能看到这篇文章全来赖于地铁上无聊打开了很久没打开的CSDNapp，切到前端分类，“不滚动”三个字立马映入眼帘，点进去的第一眼 ，就感觉是对的人了。迷茫的时候就看书，古人诚不我欺！</p><h2 id="一些忠告"><a href="#一些忠告" class="headerlink" title="一些忠告"></a>一些忠告</h2><blockquote><ul><li>能小程序就别网页开发；</li><li>不意淫不揣摩待定的需求；</li><li>坚持看图作业的优良传统；</li><li>迷茫的时候就看书，焦虑的时候去学习；</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Sticky footers 粘住底部布局</title>
    <link href="/2018/12/02/Sticky%20footers%20%E7%B2%98%E4%BD%8F%E5%BA%95%E9%83%A8%E5%B8%83%E5%B1%80/"/>
    <url>/2018/12/02/Sticky%20footers%20%E7%B2%98%E4%BD%8F%E5%BA%95%E9%83%A8%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Sticky-footers"><a href="#什么是Sticky-footers" class="headerlink" title="什么是Sticky footers"></a>什么是Sticky footers</h2><p>在网页设计中，Sticky footers设计是最古老和最常见的效果之一，大多数人都曾经经历过。它可以概括如下：如果页面内容不够长的时候，页脚块粘贴在视窗底部；如果内容足够长时，页脚块会被内容向下推送。<br><img src="/img/sticky-footer.jpeg" alt="Sticky footers"></p><h2 id="实现它最简单三种方式"><a href="#实现它最简单三种方式" class="headerlink" title="实现它最简单三种方式"></a>实现它最简单三种方式</h2><h3 id="1-利用margin-推荐，不用担心兼容性问题"><a href="#1-利用margin-推荐，不用担心兼容性问题" class="headerlink" title="1. 利用margin(推荐，不用担心兼容性问题)"></a>1. 利用margin(推荐，不用担心兼容性问题)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.content</span> &#123;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">box-sizing</span>: border-box;<br>    <span class="hljs-attribute">background-color</span>: antiquewhite;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.footer</span> &#123;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">background-color</span>: aquamarine;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-使用flex弹性布局"><a href="#2-使用flex弹性布局" class="headerlink" title="2. 使用flex弹性布局"></a>2. 使用flex弹性布局</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-tag">body</span>&#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">flex-direction</span>: column;<br>&#125;<br><span class="hljs-selector-class">.content</span> &#123;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">background-color</span>: antiquewhite;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.footer</span> &#123;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">background-color</span>: aquamarine;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-使用calc函数"><a href="#3-使用calc函数" class="headerlink" title="3. 使用calc函数"></a>3. 使用calc函数</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.content</span> &#123;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span> - <span class="hljs-number">50px</span>);<br>    <span class="hljs-attribute">background-color</span>: antiquewhite;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.footer</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">background-color</span>: aquamarine;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><a href="https://github.com/qq9694526/zhplab/tree/master/src/sticky-footers">https://github.com/qq9694526/zhplab/tree/master/src/sticky-footers</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
